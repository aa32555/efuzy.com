 <!--
####################################################################
# Copyright (c) 2024 efuzy.com and/or its subsidiaries.            #
# All rights reserved.         #
#            #
#   This source code contains the intellectual property            #
#   of its copyright holder(s), and is made available              #
#   under a license.  If you do not know the terms of              #
#   the license, please stop and do not read further.              #
#            ( I OWN the DOMAIN @ 12 ELK ST)     #
# aa3255@gmail.com ( identity is stolen no access to email         #
# use aa3255@tutamail.com      #
###################################################################
bookAppointment(D,O)
	S OR=(D("data","override")="true")
	S ERROR=0 D verifyAppointment   
	S O("data","message")="GRANDTOTAL MATCH!"
	;
	N APP M APP=D("data","appointment")
	N APPS,WARN S WARN=0 D saveAppointment(.APP,"",.ERROR,.WARN,OR)
	I ERROR S O("data","status")="error",O("data","message")="Appointment did not save, an error occured!"
	I WARN,'ERROR S O("data","status")="warn",O("data","message")=WARN("MESSAGE") Q
	I 'WARN,'ERROR S O("data","status")="booked" D
	. S NDATE=APP("date")
	. S NTIME=APP("time")
	. S NSTAFF=@%G@("STAFF","DATA",APP("services",1,"staff","id"),"name")
	. D Notify^FCM("Appointment booked by staff: "_NDATE_" "_NTIME_" with "_NSTAFF,"URL","Appointment Notifications")
	Q
       <q-img
          src="https://picsum.photos/500/300"
          :ratio="16/9"
        />
        https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b1.png

-->
<!DOCTYPE html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons|Material+Icons+Outlined|Material+Icons+Round" rel="stylesheet" type="text/css">
    <link href="https://cdn.jsdelivr.net/npm/animate.css@^4.0.0/animate.min.css" rel="stylesheet" type="text/css">
    <link href="https://cdn.jsdelivr.net/npm/quasar@1.22.10/dist/quasar.min.css" rel="stylesheet" type="text/css">
    <link href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet" type="text/css">
    <link href="https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/main.css" rel="stylesheet" type="text/css">
    <style>


.bg1 {
      height:100vh !important;
      width:100vw !important;
      background-image: url('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b1.png')!important;
      background-size: cover!important;
      background-repeat: no-repeat!important;
      
    }

    .comic1c {
      background-image: url('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/skrillex.webp')!important;
      background-size: cover!important;
      background-repeat: no-repeat!important;
    }

    .comic2c {
      background-image: url('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b2.png')!important;
      background-size: cover!important;
      background-repeat: no-repeat!important;
    }


    .comic3c {
      background-image: url('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/bgd.jpg')!important;
      background-size: cover!important;
      background-repeat: no-repeat!important;
    }


    .xterm .xterm-viewport {
    background-color: black !important;
    overflow-y: hidden !important;
}
      .bg-img-1 {
        width: 100vh !important;
        height: 100vw !important;
        background: url('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b1.png') cover;
        background-size: cover;

        .bg-img-2 {
        width: 100vh !important;
        height: 100vw !important;
        background: url('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/bgd.jpg') cover;
        background-size: cover;

        &:before {
          content: '';
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
          background-image: linear-gradient(to bottom right, #002f4b, #dc4225);
          opacity: .6;
        }
      }
      .rotating {
        transition: transform 1s ease-in-out;
      }

      .rotating:hover {
        transform: rotateZ(360deg);
      }
    }
    </style>
  </head>
  <body class="bg1">
    <div id="q-app" class="flex fit flex-center">
      <div class="full-width" style="width:100%;">
        <q-tabs v-show="showaa1" v-model="tab" inline-label class="bg-black text-red" class="full-width" style="width:100%;">
          <q-tab class="bg-black"  style="color:#00ff41" name="learnm" label="learn MUMPS (M) by Order of Predator God" @click="learnm"></q-tab>
          <q-tab v-show="false" class="bg-black text-red" name="learnmpg" label="(M) Full Guide" @click="window.open('https://github.com/aa32555/efuzy.com/blob/staging/docs/GT.M%20Programmers%20Guide.pdf','_blank')"></q-tab>
          <q-space></q-space>
          <q-tab v-show="false" class="bg-black text-red" name="mystory" label="my story" @click="mystorydialog=true"></q-tab>
          <q-tab name="repo" @click="repo" label="Repo"></q-tab>
          <q-tab name="li" @click="li" label="LinkedIn"></q-tab>
          <q-tab name="youtube" label="youtube" @click="youtube"></q-tab>
          <q-tab name="Instagram" label="Instagram" @click="insta"></q-tab>
          <q-tab name="paypal" label="Donate (paypal @asolok)" @click="paypal"></q-tab>
        </q-tabs>
      </div>
      <div>
        <q-card :class="'comic'+
        ( host==='ahmed'?'1':
        ( host==='joshua'?'2': host==='bastet'?'3':'1')) +'c'">
          <q-item clickable v-ripple @click="showaa1=!showaa1" class="text-green bg-black">
            <q-item-section side>
              <q-avatar square size="150px" v-if="host==='joshua'">
                <img src="https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/Joshua.png">
              </q-avatar>
              <q-avatar square size="150px" v-if="host==='ahmed'">
                <img src="https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/155005073.jpg">
              </q-avatar>
              <q-avatar square size="150px" v-if="host==='bastet'">
                <img src="https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/bastet.png">
              </q-avatar>
              <q-spinner-dots size="3rem" style="color:white;background-color: black;" v-show="showsd"></q-spinner-dots>
            </q-item-section>
          </q-item>     
               <div id="terminal" class="flex-center justify-around" style="overflow:hidden;margin:0 auto;"></div>
        </q-card>
        
      </div>
<!--

********************************************************
-->



<q-dialog v-model="imgdialog" :maximized="true" transition-show="slide-up" transition-hide="slide-down" >
  <q-card style="background-image: linear-gradient(to bottom right,#002f4b,#dc4225);">
      <q-img :src="modalimg" :ratio="16/9" ></q-img>
     <q-btn label="OK" @click="imgdialog=false">
     </q-btn>
  </q-card>
</q-dialog>

<!--

********************************************************
-->


<q-dialog v-model="sessionIdialog" :maximized="true" transition-show="slide-up" transition-hide="slide-down" >
  <q-card style="background-image: linear-gradient(to bottom right,#002f4b,#dc4225);">
    <q-bar>
            <q-space></q-space>
            <q-btn dense flat icon="close" @click="sessionIdialog = false"></q-btn>
          </q-bar>
    <div class="q-pa-md">
      <q-stepper
        v-model="sessionIsteppermodel"sessionIdialog
        color="amber-3"
        animated
      >
        <q-step
          :name="1"
          title="Session I ( Dollar P )"
          :done="false"
        >
<pre style="background-color:black;color:#00FF41;"> <code style="background-color:#000000;color:#00FF41;">
  $Piece()
  Returns a substring delimited by a specified string delimiter made up of one or more characters. In M, $PIECE() returns a logical
  field from a logical record.
  The format for the $PIECE function is:
  $P[IECE](expr1,expr2[,intexpr1[,intexpr2]])
  • The first expression specifies the string from which $PIECE() computes its result.
  • The second expression specifies the delimiting string that determines the piece "boundaries"; if this argument is an empty
  string, $PIECE() returns an empty string.
  • If the second expression does not appear anywhere in the first expression, $PIECE() returns the entire first expression (unless
  forced to return an empty string by the second integer expression).
  • The optional first integer expression (third argument) specifies the beginning piece to return; if this argument is missing,
  $PIECE() returns the first piece.
  • The optional second integer expression (fourth argument) specifies the last piece to return. If this argument is missing,
  $PIECE() returns only one piece unless the first integer expression is zero (0) or negative, in which case it returns a null
  string. If this argument is less than the first integer expression, $PIECE() returns an empty string.
  • If the second integer expression exceeds the actual number of pieces in the first expression, $PIECE() returns all of the
  expression after the delimiter selected by the first integer expression.
  • The $PIECE() result never includes the "outside" delimiters; however, when the second integer argument specifies multiple
  pieces, the result contains the "inside" occurrences of the delimiter.
  Functions
  231
  • $PIECE() can also be used as tool for efficiently using values that contain multiple elements or fields, each of which may be
  variable in length.
  • Applications typically use a single character for a $PIECE() delimiter (second argument) to minimize storage overhead,
  and increase efficiency at run-time. The delimiter must be chosen so the data values never contain the delimiter. Failure
  to enforce this convention with edit checks may result in unanticipated changes in the position of pieces within the data
  value. The caret symbol (^), backward slash (\), and asterisk (*) characters are examples of popular visible delimiters. Multiple
  character delimiters may reduce the likelihood of conflict with field contents. However, they decrease storage efficiency, and
  are processed with less efficiency than single character delimiters. Some applications use control characters, which reduce
  the chances of the delimiter appearing in the data but sacrifice the readability provided by visible delimiters.
  • A SET command argument can have something that has the format of a $PIECE() on the left-hand side of its equal sign
  (=). This construct permits easy maintenance of individual pieces within a string. It also can be used to generate a string of
  delimiters. For more information on SET $PIECE(), refer to “Set” (page 143).
  • $PIECE() can also be used as target in a SET command to change part of the value of a node. Also, when SET arguments
  have multiple parenthesized (set-left) targets and a target is used as a subscript in more than one item in the list of targets
  that follow, all the targets use the before-SET value (not the after-SET value) in conformance to the M-standard. For more
  information on SET $PIECE(), refer to “Set” (page 143).
  • For a proces started in UTF-8 mode, $PIECE() interprets the string arguments as UTF-8 encoded. With VIEW "BADCHAR"
  enabled, $PIECE() produces a run-time error when it encounters a malformed character, but it does not process the characters
  that fall after the span specified by the arguments.
  • $ZPIECE() is the parallel function of $PIECE(). Irrespective of the settings of VIEW "BADCHAR" and $ZCHSET, $ZPIECE()
  interprets string arguments as a sequence of bytes (rather than a sequence of characters) and can perform all byte-oriented
  $PIECE() operations. For more information, refer to “$ZPIece()” (page 272).
  Examples of $PIECE()
  Example:
  GTM>for i=0:1:3 write !,$piece("1 2"," ",i),"<"
  <
  1<
  2<
  <
  GTM>
  This loop displays the result of $PIECE(), specifying a space as a delimiter, a piece position "before," first and second, and "after"
  the string.
  Example:
  GTM>for i=-1:1:3 write !,$piece("1 2"," ",i,i+1),"<"
  <
  1<
  1 2<
  2<
  <
  GTM>
  This example is similar to the previous example except that it displays two pieces on each iteration. Notice the delimiter (a
  space) in the middle of the output for the third iteration, which displays both pieces.
  Functions
  232
  Example:
  for p=1:1:$length(x,"/") write ?p-1*10,$piece(x,"/",p)
  This example uses $LENGTH() and $PIECE() to display all the pieces of x in columnar format.
  Example:
  GTM>set $piece(x,".",25)="" write x
  ........................
  This SETs the 25th piece of the variable x to null, with a delimiter of a period. This produces a string of 24 periods preceding the
  null.
</code>
</pre> 
        </q-step>
      </q-stepper>
    </div>
  </q-card>
</q-dialog>
      <q-dialog v-model="learnmdialog" persistent :maximized="maximizedToggle" transition-show="slide-up" transition-hide="slide-down">
        <q-card style="background-image: linear-gradient(to bottom right,#002f4b,#dc4225);">
          <q-bar>
            <q-space></q-space>
            <q-btn dense flat icon="minimize" @click="maximizedToggle = false" :disable="!maximizedToggle">
              <q-tooltip :disabled="maximizedToggle">Minimize</q-tooltip>
            </q-btn>
            <q-btn dense flat icon="crop_square" @click="maximizedToggle = true" :disable="maximizedToggle">
              <q-tooltip disabled="!maximizedToggle">Maximize</q-tooltip>
            </q-btn>
            <q-btn dense flat icon="close" @click="learnmdialog = false"></q-btn>
          </q-bar>
          <q-card-section class="q-pt-none">
            <q-splitter
              v-model="splitterModel"
              style="height: 100%;"
            >
      <template v-slot:after>
        <div class="q-pa-md">
        
            <q-card-section>
             <div id="terminalii" class="flex flex-center q-pa-sm q-gutter-sm" style="overflow:hidden;margin:0 auto"></div>
              <div class="flex-center justify-around" >
                <q-btn dense flat round class="q-pa-sm" label="write" @click="porocessNotes"></q-btn>
                <q-btn label="Start Session 1 ($P)" @click="startSessionI"></q-btn>
                <q-btn label="launchImge" @click="limage('https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b1.png')"></q-btn>
                <q-btn label="THE BUTTON" @click="sessionIdialog=true"></q-btn>
              </div>
            </q-card-section>
          
            <q-card-section>
              <div class="q-pa-md q-gutter-sm" style="width:100%;height:100%;">
                <h5>Notes</h5>
                <q-editor
                  v-model="editor"
                  flat
                  content-class="bg-amber-3"
                  toolbar-text-color="white"
                  toolbar-toggle-color="yellow-8"
                  toolbar-bg="primary"
                  :toolbar="[
                    ['bold', 'italic', 'underline'],
                    [{
                      label: $q.lang.editor.formatting,
                      icon: $q.iconSet.editor.formatting,
                      list: 'no-icons',
                      options: ['p', 'h3', 'h4', 'h5', 'h6', 'code']
                    }]
                  ]"
              ></q-editor>
              </div>
            </q-card-section>
          </div>
        </template>
        <template v-slot:before>
          <div class="q-pa-md">
           
            <q-card-section>
             <br/><br/>
<pre style="background-color:black"> <code style="background-color:#000000;color:#00FF41;">
  <h3>
    Chapter 7.
  </h3>
  <br/><br/>
Chapter 7. Functions
Revision History
Revision V7.1-003 23 November 2023 • In “$ZPEEK()” (page 274), Revise the Note
on selection among multiple replication
journal pools
Revision V7.1-001 26 June 2023 • In “Argument Keywords of $VIEW()” (page
243), Fix typo for JNLPOOL
Revision V7.1-000 04 April 2023 • In “Argument Keywords of $VIEW()” (page
243), add $VIEW("FULL_BOOLEAN")
description string for new
EXTENDED_BOOLEAN option.
• In “$ZPEEK()” (page 274), add a note
about $ZPEEK of jnlpool fields and multiple
replication instances
Revision V7.0-005 02 December 2022 • In “Examples of $ZAUDitlog()” (page 251),
Fix a typo in $zauditlog example description.
• In “$ZAUditlog” (page 251), add
$ZAUDITLOG()
• In “$ZSOCKET()” (page 276), corrected typo
Revision V7.0-004 20 September 2022 • In “$ZSOCKET()” (page 276), add new
$ZSOCKET() keywords for getsockopt() items.
Disabled support for pre-TLSv1.2
Revision V7.0-003 24 June 2022 • In “Argument Keywords of $VIEW()” (page
243), add new $VIEW() keyword "DEVICE"
• In “Examples of $VIEW()” (page 246), add
new $VIEW() keyword "DEVICE"
• In “$ZSOCKET()” (page 276), add new
$ZSOCKET() keywords for getsockopt() items.
Disabled support for pre-TLSv1.2
Revision V7.0-002 23 March 2022 • In “$ZJOBEXAM()” (page 267), add the
second optional argument
• In “$ZDATE Format Specification
Elements” (page 262), qdd 'YYYY' as
another option (after 'YEAR') for getting a four
digit year.
• In “$ZGetjpi()” (page 266), fixed a typo
Revision V7.0-001 24 November 2021 • In “$ZSOCKET()” (page 276), add an entry
for the BLOCKING keyword.
Revision V6.3-012 08 April 2020 • In “Examples of $INCREMENT()” (page
223), fix case of variable name
Revision V6.3-010 31 October 2019 • In “Examples of $ZATRANSFORM()” (page
251), fix typo
Functions
212
• In “$ZATRansform” (page 250), add
changes for 2 (two) and -2 (minus two) as
optional third arguments.
• In “$ZCOnvert()” (page 259), remove the
statement that character code "T" does not
work in M mode; correct an example.
Revision V6.3-007 04 February 2019 • In “Argument Keywords of $VIEW()” (page
243), adjust probecrit output for V6.3-007
• In “$ZLength()” (page 269), separate the
last bullet points into two parts.
Revision V6.3-006 26 October 2018 • In “$ASCII()” (page 214), UTF-8 mode
tweaks.
• In “$Char()” (page 215), UTF-8 mode
tweaks.
• In “Examples of $ASCII()” (page 214), UTF-8
mode tweaks.
• In “Examples of $CHAR()” (page 215),
UTF-8 mode tweaks
• In “Examples of $ZWIDTH()” (page 288),
UTF-8 tweaks and minor corrections.
• In “$Extract()” (page 217), UTF-8 mode
tweaks.
• In “$ZCOnvert()” (page 259), minor
corrections.
• In “$ZSUBstr()” (page 283), UTF-8 mode
tweaks.
• In “$ZWidth()” (page 287), minor
corrections.
Revision V6.3-005 29 June 2018 • In “Argument Keywords of $VIEW()” (page
243), update the description of STATSHARE
argument keyword.
• In “$ZSOCKET()” (page 276), add note on
SSLv3 default
• In “$ZTRNLNM()” (page 287), state that
expr6 is optional and add an example
Revision V6.3-004 23 March 2018 • In “Argument Keywords of $VIEW()” (page
243), add information about the
STATSHARE keyword; improve the description
of GVSTAT
Revision V6.3-003 12 December 2017 • In “Argument Keywords of $VIEW()” (page
243), fix format for gvstats
• In “$ZDATA()” (page 260), typo "reflects" ->
"reflect"
Revision V6.3-001 20 March 2017 • In “Argument Keywords of $VIEW()” (page
243), Update description of
Functions
213
$VIEW("SPSIZE") to include two additional
values returned.
• In “Examples of $VIEW()” (page 246),
updated gvstats output
• In “$ZATRansform” (page 250), added the
description of $ZATRANSFORM().
• In “$ZCOllate()” (page 258), add the
description of $ZCOLLATE().
• In “$ZPIece()” (page 272), removed spurious
characters from an example;corrected the
abbreviation for $ZPIECE()
• In “$ZSIGPROC()” (page 282), removed
Tru64.
• In “$ZSOCKET()” (page 276), added the
ALL, SESSION, OPTIONS, and TLS keywords
• In “$ZWRite()” (page 288), added
information about the second argument
and information about string inflation going
to zwrite format. Modified description to
use "argument" as a user found the use of
expression unclear.
Revision V6.2-001 27 February 2015 • Updated “$ZTRIgger()” (page 285)
for V6.2-001 multi-line XECUTE string
enhancements, $ZTRIGGER() return status,
specified that $ZTRIGGER() always operates
within a TP transaction even if it needs to
implicitly create one, and added a note on the
support of triggers in spanning regions.
• Added a new section called
“$ZSOCKET()” (page 276).
• In “$ZPEEK()” (page 274), specified that
$ZPEEK() function generates an UNDEF
error when VIEW UNDEF is not set and
format parameter is specified but is undefined
and added the JNL[REG]:region and
JBF[REG]:region keyword first arguments.
• In “Argument Keywords of $VIEW()” (page
243), added "RTNCHECKSUM" as a new
ARG1.
Revision V6.1-000 28 August 2014 • In “$ZGetjpi()” (page 266), corrected
the descriptions of CSTIME and CUTIME
keywords.
Revision V6.0-003 24 February 2014 • Added the description of “$ZPEEK()” (page
274).
Revision V6.0-001 21 March 2013 • Added the descriptions of “$ZWRite()” (page
288) and “$ZGetjpi()” (page 266).
• Added information about TRIGGER and
ZINTR return values for $STACK(lvl) in
“$STack()” (page 237).

<h5 id="functions"> Functions</h5>
214
This chapter describes M language Intrinsic Functions implemented in GT.M. Traditional string processing functions
have parallel functions that start with the letter "z". The parallel functions extend the byte-oriented functionality of their
counterparts to UTF-8 mode. They are helpful when applications need to process binary data including blobs, binary byte
streams, bit-masks, and so on.
Other functions that start with the letter "z" and do not have counterparts implement new functionality and are GT.M additions
to the ANSI standard Intrinsic Functions. The M standard specifies standard abbreviations for Intrinsic Functions and rejects
any non-standard abbreviations.
M Intrinsic Functions start with a single dollar sign ($) and have one or more arguments enclosed in parentheses () and
separated by commas (,). These functions provide expression results by performing actions that are impossible or difficult to
perform using M commands.
$ASCII()
Returns the integer ASCII code for a character in the given string. For a mumps process started in UTF-8 mode, $ASCII() returns
the integer Unicode® UTF-8 code-point value of a character in the given string.
The format for the $ASCII function is:
$A[SCII](expr[,intexpr])
• The expression is the source string from which $ASCII() extracts the character it decodes.
• intexpr contains the position within the expression of the character that $ASCII() decodes. If intexpr is missing, $ASCII()
returns a result based on the first character position.
• If intexpr evaluates to before the beginning or after the end of the expression, $ASCII() returns a value of negative one (-1).
$ASCII() provides a means of examining non-graphic characters in a string. When used with $CHAR(), $ASCII() also provides a
means to perform arithmetic operations on the codes associated with characters.
$ZASCII() is the parallel function of $ASCII(). $ZASCII() interprets the string argument as a sequence of bytes (rather than a
sequence of characters) and can perform all byte-oriented $ASCII() operations. For more information, refer to “$ZAscii()” (page
249).
Examples of $ASCII()
Example:
GTM>For i=0:1:3 Write !,$Ascii("Hi",i)
-1
72
73
-1
GTM>
This loop displays the result of $ASCII() specifying a character position before, first and second positions, and after the string.
Example:
GTM>Write $ZCHSET
UTF-8
Functions
215
GTM>Write $Ascii("主")
20027
GTM>Write $$FUNC^%DH("20027")
00004E3B
In this example, 20027 is the integer equivalent of the hexadecimal value 4E3B. U+4E3B is a character in the CJK Ideograph
block of the Unicode® standard.
$Char()
Returns a string of one or more characters corresponding to integer ASCII codes specified in its argument(s). For a process
started in UTF-8 mode, $CHAR() returns a string composed of characters represented by the integer equivalents of the
Unicode® code-points specified in its argument(s).
The format for the $CHAR function is:
$C[HAR](intexpr[,...])
• The integer expression(s) specify the codes of the character(s) $CHAR() returns.
• The M standard does not restrict the number of arguments to $CHAR(). However, GT.M does limit the number of arguments
to a maximum of 254. $CHAR() provides a means of producing non-graphic characters, as such characters cannot appear
directly within an M string literal. When used with $ASCII(), $CHAR() can also perform arithmetic operations on the codes
associated with characters.
• With VIEW "BADCHAR" enabled, $CHAR() produces a run-time error if any expression evaluates to a code-point value that
is not a UTF-8 character. GT.M determines from ICU which characters are illegal.
• $ZCHAR() is the parallel function of $CHAR(). $ZCHAR() returns a sequence of bytes (rather than a sequence of characters)
and can perform all byte-oriented $CHAR() operations. For more information, refer to “$ZCHar()” (page 257).
Examples of $CHAR()
Example:
GTM>write $char(77,85,77,80,83,7)
MUMPS
GTM>
This example uses $CHAR() to WRITE the word MUMPS and signal the terminal bell.
Example:
set nam=$extract(nam,1,$length(nam)-1)_$char($ascii(nam,$length(nam))-1)
This example uses $CHAR() and $ASCII() to set the variable nam to a value that immediately precedes its previous value in the
set of strings of the same length as nam.
Example:
GTM>write $zchset
UTF-8
GTM>write $char(20027)
主
Functions
216
GTM>write $char(65)
A
In the above example, the integer value 20027 is the Unicode® character "主" in the CJK Ideograph block. Note that the output
of the $CHAR() function for values of integer expression(s) from 0 through 127 does not vary with choice of the character
encoding scheme. This is because 7-bit ASCII is a proper subset of UTF-8 character encoding scheme. The representation of
characters returned by the $CHAR() function for values 128 through 255 differ for each character encoding scheme.
$Data()
Returns an integer code describing the value and descendent status of a local or global variable.
The format for the $DATA function is:
$D[ATA](glvn)
• The subscripted or unsubscripted global or local variable name specifies the target node.
• If the variable is undefined, $DATA() returns 0.
• If the variable has a value but no descendants, $DATA() returns 1.
• If the variable has descendants but no value, $DATA() returns 10.
• If the variable has a value and descendants, $DATA() returns 11.
• $ZDATA() extends $DATA() to reflects the current alias state of the lvn or name argument to identify alias and alias
container variables. For more information, refer to “$ZDATA()” (page 260).
The following table summarizes $DATA() return values.
$DATA() Results
VALUE
DESCENDANTS (NO) DESCENDANTS (YES)
NO 0 10
YES 1 11
$DATA() return values can also be understood as a pair of truth-values where the left describes descendants and the right
describes data 1 and where M suppresses any leading zero (representing no descendants).
Examples of $DATA()
Example:
GTM>Kill Write $Data(a)
0
GTM>Set a(1)=1 Write $Data(a(1))
1
GTM>Write $Data(a)
Functions
217
10
GTM>Set a=0 Write $Data(a)
11
GTM>
This uses $DATA to display all possible $DATA() results.
Example:
lock ^ACCT(0)
if '$data(^ACCT(0)) set ^ACCT(0)=0
set (ACCT,^ACCT(0))=^ACCT(0)+1
lock
This uses $DATA() to determine whether a global node requires initialization.
Example:
for set cus=$O(^cus(cus)) quit:cus="" if $data(^(cus))>1 do WORK
This uses $DATA() to determine whether a global node has descendants and requires additional processing.
$Extract()
Returns a substring of a given string.
The format for the $EXTRACT function is:
$E[XTRACT](expr[,intexpr1[,intexpr2]])
• The expression specifies a string from which $EXTRACT() derives a substring.
• The first optional integer expression (second argument) specifies the starting character position in the string. If the starting
position is beyond the end of the expression, $EXTRACT() returns an empty string. If the starting position is zero (0) or
negative, $EXTRACT() starts at the first character; if this argument is omitted, $EXTRACT() returns the first character of the
expression. $EXTRACT() numbers character positions starting at one (1) (that is, the first character of a string is at position
one (1)).
• The second optional integer expression (third argument) specifies the ending character position for the result. If the ending
position is beyond the end of the expression, $EXTRACT() stops with the last character of the expression. If the ending
position precedes the starting position, $EXTRACT() returns an empty string. If this argument is omitted, $EXTRACT()
returns one character at most.
$EXTRACT() provides a tool for manipulating strings based on character positions.
For a mumps process started in UTF-mode, $EXTRACT interprets the string arguments as UTF-8 encoded. With VIEW
"BADCHAR" enabled, $EXTRACT() produces a run-time error when it encounters a character in the reserved range of the
Unicode® standard, but it does not process the characters that fall after the span specified by the arguments. The parallel
function of $EXTRACT() is $ZEXTRACT(). Use $ZEXTRACT() for byte-oriented operations. For more information, refer to
“$ZExtract()” (page 264).
$EXTRACT() can be used on the left-hand side of the equal sign (=) of a SET command to set a substring of a string. This
construct permits easy maintenance of individual pieces within a string. It can also be used to right justify a value padded with
blank characters. For more information on SET $EXTRACT(), refer to “Set” (page 143) in the Commands chapter.
Functions
218
Examples of $EXTRACT()
Example:
GTM>for i=0:1:3 write !,$extract("HI",i),"<"
<
H<
I<
<
GTM>
This loop displays the result of $EXTRACT(), specifying no ending character position and a beginning character position
"before" first and second positions, and "after" the string.
Example:
GTM>For i=0:1:3 write !,$extract("HI",1,i),"<"
<
H<
HI<
HI<
GTM>
This loop displays the result of $EXTRACT() specifying a beginning character position of 1 and an ending character position
"before, " first and second positions, and "after" the string.
Example:
GTM>zprint ^trim
trim(x)
 new i,j
 for i=1:1:$length(x) quit:" "'=$extract(x,i)
 for j=$length(x):-1:1 quit:" "'=$extract(x,j)
 quit $extract(x,i,j)
GTM>set str=" MUMPS "
GTM>write $length(str)
7
GTM>write $length($$^trim(str))
5
GTM>
This extrinsic function uses $EXTRACT() to remove extra leading and trailing spaces from its argument.
$Find()
Returns an integer character position that locates the occurrence of a substring within a string.
The format for the $FIND function is:
$F[IND](expr1,expr2[,intexpr])
• The first expression specifies the string within which $FIND() searches for the substring.
• The second expression specifies the substring for which $FIND() searches.
Functions
219
• The optional integer expression identifies the starting position for the $FIND() search. If this argument is missing, zero (0), or
negative, $FIND() begins its search in the first position of the string.
• If $FIND() locates the substring, it returns the position after the last character of the substring. If the end of the substring
coincides with the end of the string (expr1), it returns an integer equal to the length of the string plus one ($L(expr1)+1).
• If $FIND() does not locate the substring, it returns zero (0).
• For a process started in UTF-8 mode, $FIND() interprets the string arguments as UTF-8 encoded. With VIEW "BADCHAR"
enabled, $FIND() produces a run-time error when it encounters a malformed character, but it does not process the characters
that fall after the span specified by the arguments.
• $ZFIND() is the Z equivalent function $FIND(). Irrespective of the settings of VIEW "BADCHAR" and $ZCHSET, $ZFIND()
interprets argument as a sequence of bytes (rather than a sequence of characters) and can perform byte-oriented $FIND()
operations.For more information, refer to “$ZFind()” (page 265).
$FIND() provides a tool to locate substrings. The ([) operator and the two-argument $LENGTH() are other tools that provide
related functionality.
Examples of $FIND()
Example:
GTM>write $find("HIFI","I")
3
GTM>
This example uses $FIND() to WRITE the position of the first occurrence of the character "I." The return of 3 gives the position
after the "found" substring.
Example:
GTM>write $find("HIFI","I",3)
5
GTM>
This example uses $FIND() to WRITE the position of the next occurrence of the character "I" starting in character position
three.
Example:
GTM>set t=1 for set t=$find("BANANA","AN",t) quit:'t write !,t
4
6
GTM>
This example uses a loop with $FIND() to locate all occurrences of "AN" in "BANANA". $FIND() returns 4 and 6 giving the
positions after the two occurrences of "AN".
Example:
GTM>set str="MUMPS databases are hierarchical"
GTM>Write $find(str," ")
7
GTM>Write $find(str,"Z")
0
Functions
220
GTM>Write $find(str,"d",1)
8
GTM>Write $find(str,"d",10)
0
The above example searches a string for a sub string, and returns an integer value which corresponds to the next character
position after locating the sub string.
$FNumber()
Returns a string containing a formatted number.
The format for the $FNUMBER function is:
$FN[UMBER](numexpr,expr[,intexpr])
• The numeric expression specifies the number that $FNUMBER() formats.
• The expression (second argument) specifies zero or more single character format control codes; if the expression contains
any character other than the defined codes, $FNUMBER() generates a run-time error.
• The optional integer expression (third argument) specifies the number of digits after the decimal point. If the numeric
expression has more digits than specified by this argument, $FNUMBER() rounds to obtain the result. If the numeric
expression has fewer digits than specified by this argument, $FNUMBER() zero-fills to obtain the result.
• When the optional third argument is specified and the first argument evaluates to a fraction between -1 and 1, $FNUMBER()
returns a number with a leading zero (0) before the decimal point (.).
$FNUMBER() formats or edits numbers, usually for reporting. For more information on rounding performed by $FNUMBER(),
refer to “$Justify()” (page 223).
The formatting codes are:
• + : Forces a "+" on positive values.
• - : Suppresses the "-" on negative values.
• , : Inserts commas every third position to the left of the decimal within the number.
• T : Represents the number with a trailing, rather than a leading sign; positive numbers have a trailing space unless the
expression includes a plus sign (+).
• P : Represents negative values in parentheses, positive values with a space on either side; combining with any other code
except comma (,) causes a run-time error.
Examples of $FNUMBER()
Example:
GTM>do ^fnum
fnum;
 zprint ^fnum
 set X=-100000,Y=2000
 write "SUPPRESS NEGATIVE SIGN:",?35,$FNumber(X,"-"),!
Functions
221
 write "TRAILING SIGN:",?35,$FNumber(X,"T"),!
 write "NEGATIVE NUMBERS IN ():",?35,$FNumber(X,"P"),!
 write "COMMAS IN NUMBER:",?35,$FNumber(X,","),!
 write "NUMBER WITH FRACTION:",?35,$FNumber(X,"",2),!
 write "FORCE + SIGN IF POSITIVE:",?35,$FNumber(Y,"+"),!
SUPPRESS NEGATIVE SIGN: 100000
TRAILING SIGN: 100000-
NEGATIVE NUMBERS IN (): (100000)
COMMAS IN NUMBER: -100,000
NUMBER WITH FRACTION: -100000.00
FORCE + SIGN IF POSITIVE: +2000
Example:
set x=$fnumber(x,"-")
This example uses $FNUMBER() to SET x equal to its absolute value.
$Get()
Returns the value of a local or global variable if the variable has a value. If the variable has no value, the function returns a
value specified by an optional second argument, and otherwise returns an empty string.
The format for the $GET function is:
$G[ET](glvn[,expr])
• The subscripted or unsubscripted global or local variable name specifies the node for which $GET() returns a value.
• If the global or local variable has a data value, $GET() returns the value of the variable.
• If the global or local variable has no data value, $GET() returns the value of the optional expression (second argument), or an
empty string if the expression is not specified.
M defines $GET(x,y) as equivalent to:
$Select($Data(x)[0:y,1:x)
and $GET(x) as equivalent to:
$GET(x,"")
$GET() provides a tool to eliminate separate initialization of variables. This technique may provide performance benefits
when used to increase the density of a sparse global array by eliminating nodes that would otherwise hold absent optional
information. On the other hand, some uses of one argument $GET() can mask logic problems.
GT.M has a "NOUNDEF" mode of operation, which treats all variable references as if they were arguments to a one argument
$GET(). The VIEW command controls "NOUNDEF" mode.
Examples of $GET()
Example:
setstatus;
 if '$data(^PNT(NAME,TSTR)) set STATUS="NEW TEST"
Functions
222
 else if ^PNT(NAME,TSTR)="" set STATUS="WAITING FOR RESULT"
 else set STATUS=^PNT(NAME,TSTR)
This example can be reduced to two lines of code by using $GET(), shown in the following example. However, by using $GET()
in its one-argument form, the distinction between an undefined variable and one with a null value is lost:
set STATUS=$get(^PNT(NAME,TSTR))
if STATUS="" set STATUS="WAITING FOR RESULT"
This is solved by using the two-argument form of $GET():
set STATUS=$get(^PNT(NAME,TSTR),"NEW TEST")
if STATUS="" set STATUS="WAITING FOR RESULT"
$Increment()
Atomically adds (increments) a global variable by a numeric value. Note that increment is atomic, but the evaluation of the
expression is not, unless inside a transaction (TStart/TCommit). The function also works on local variables, but has less benefit
for locals as it does not (need to) provide ACID behavior.
The format of the $INCREMENT function is:
$INCREMENT(glvn[,numexpr])
• $I, $INCR, $INCREMENT, $ZINCR, and $ZINCREMENT are considered as valid synonyms of the full function name.
• $INCREMENT() returns the value of the glvn after the increment.
• If not specified, numexpr defaults to 1. Otherwise, $INCREMENT() evaluates the "numexpr" argument before the "glvn"
argument.
• numexpr can be a negative value.
• Since it performs an arithmetic operation, $INCREMENT() treats glvn as numeric value. $INCREMENT treats glvn as if it
were the first argument of an implicit $GET() before the increment. If the value of glvn is undefined $INCREMENT treats
it as having empty string , which means it treats it as a numeric zero (0) (even if glvn is a global variable that resides on a
remote node and is accessed through a GT.CM GNP server).
• If $INCREMENT() occurs inside a transaction ($TLevel is non-zero), or if glvn refers to a local variable, it is equivalent to SET
glvn=$GET(glvn)+numexpr.
• If $INCREMENT() occurs outside a transaction ($TLevel is zero) and glvn refers to a global variable, the function acts as
a SET glvn=$GET(glvn)+numexpr performed as an Atomic, Consistent and Isolated operation. Note that $INCREMENT()
performs the evaluation of numexpr before it starts the Atomic, Consistent, Isolated incrementing of the glvn. If the region
containing the glvn is journaled, then the $INCREMENT() is also Durable. Only BG, MM (OpenVMS only) and GT.CM GNP
access methods are supported for the region containing the global variable (glvn). GT.CM OMI and GT.CM DDP access
methods do not support this operation and there are no current plans to add such support.
• $INCREMENT() does not support global variables that have NOISOLATION turned ON (through the VIEW "NOISOLATION"
command), and a $INCREMENT() on such a variable, triggers a GVINCRISOLATION run-time error.
• The naked reference is affected by the usage of global variables (with or without indirection) in the glvn and/or numexpr
components. The evaluation of "numexpr" ahead of "glvn" determines the value of the naked reference after the
$INCREMENT. If neither glvn or numexpr contain indirection, then $INCREMENT sets the naked reference as follows:
Functions
223
• glvn, if glvn is a global, or
• the last global reference in "numexpr" if glvn is a local, or
• unaffected if neither glvn nor numexpr has any global reference.
Examples of $INCREMENT()
Example:
GTM>set i=1
GTM>write $increment(i)
2
GTM>write $increment(i)
3
GTM>write $increment(i)
4
GTM>write $increment(i)
5
GTM>write i
5
GTM>write $increment(i,-2)
3
GTM>write i
3
GTM>
This example increments the value of i by 1 and at the end decrements it by 2. Note that the default value for incrementing a
variable is 1.
$Justify()
Returns a formatted string.
The format for the $JUSTIFY function is:
$J[USTIFY](expr,intexpr1[,intexpr2])
• The expression specifies the string to be formatted by $JUSTIFY().
• The first integer expression (second argument) specifies the minimum size of the resulting string. If the first integer
expression is larger than the length of the expression, $JUSTIFY() right justifies the expression to a string of the specified
length by adding leading spaces. Otherwise, $JUSTIFY() returns the expression unmodified unless specified by the second
integer argument.
• The optional second integer expression (third argument) specifies the number of digits to follow the decimal point in the
result, and forces $JUSTIFY() to evaluate the expression as numeric. If the numeric expression has more digits than this
argument specifies, $JUSTIFY() rounds to obtain the result. If the expression had fewer digits than this argument specifies,
$JUSTIFY() zero-fills to obtain the result.
• When the second argument is specified and the first argument evaluates to a fraction between -1 and 1, $JUSTIFY() returns a
number with a leading zero (0) before the decimal point (.).
Functions
224
$JUSTIFY() fills expressions to create fixed length values. However, if the length of the specified expression exceeds the
specified field size, $JUSTIFY() does not truncate the result (although it may still round based on the third argument). When
required, use $EXTRACT() to perform truncation.
$JUSTIFY() optionally rounds the portion of the result after the decimal point. In the absence of the third argument, $JUSTIFY()
does not restrict the evaluation of the expression. In the presence of the third (rounding) argument, $JUSTIFY() evaluates the
expression as a numeric value. The rounding algorithm can be understood as follows:
• If necessary, the rounding algorithm extends the expression to the right with 0s (zeros) to have at least one more digit than
specified by the rounding argument.
• Then, it adds 5 (five) to the digit position after the digit specified by the rounding argument.
• Finally, it truncates the result to the specified number of digits. The algorithm rounds up when excess digits specify a half or
more of the last retained digit and rounds down when they specify less than a half.
• For a process started in UTF-8 mode, $JUSTIFY() interprets the string argument as UTF-8 encoded. With VIEW "BADCHAR"
enabled, $JUSTIFY() produces a run-time error when it encounters a malformed character.
• $ZJUSTIFY() is the parallel function of $JUSTIFY(). Irrespective of the settings of VIEW "BADCHAR" and $ZCHSET,
$ZJUSTIFY() interprets argument as a sequence of bytes (rather than a sequence of characters) and can perform all byteoriented $JUSTIFY() operations. For more information, refer to “$ZJustify()” (page 268).
Examples of $JUSTIFY()
Example:
GTM>write ":",$justify("HELLO",10),":",!,":",$justify("GOODBYE",5),":"
: HELLO:
:GOODBYE:
GTM>
This uses $JUSTIFY() to display "HELLO" in a field of 10 spaces and "GOODBYE" in a field of 5 spaces. Because the length of
"GOODBYE" exceeds five spaces, the result overflows the specification.
Example:
GTM>write "1234567890",!,$justify(10.545,10,2)
1234567890
 10.55
GTM>
This uses $JUSTIFY() to WRITE a rounded value right justified in a field of 10 spaces. Notice that the result has been rounded
up.
Example:
GTM>write "1234567890",!,$justify(10.544,10,2)
1234567890
 10.54
GTM>
Again, this uses $JUSTIFY() to WRITE a rounded value right justified in a field of 10 spaces. Notice that the result has been
rounded down.
Functions
225
Example:
GTM>write "1234567890",!,$justify(10.5,10,2)
1234567890
 10.50
GTM>
Once again, this uses $JUSTIFY() to WRITE a rounded value right justified in a field of 10 spaces. Notice that the result has been
zero-filled to 2 places.
Example:
GTM>write $justify(.34,0,2)
0.34
GTM>
This example uses $JUSTIFY to ensure that the fraction has a leading zero. Note the use of a second argument of zero in the
case that rounding is the only function that $JUSTIFY is to perform.
$Length()
Returns the length of a string measured in characters, or in "pieces" separated by a delimiter specified by one of its arguments.
The format for the $LENGTH function is:
$L[ENGTH](expr1[,expr2])
• The first expression specifies the string that $LENGTH() "measures".
• The optional second expression specifies the delimiter that defines the measure; if this argument is missing, $LENGTH()
returns the number of characters in the string.
• If the second argument is present and not an empty string, $LENGTH returns one more than the count of the number of
occurrences of the second string in the first string; if the second argument is an empty string, the M standard specifies that
$LENGTH() returns a zero (0).
• $LENGTH() provides a tool for determining the lengths of strings in two ways, characters and pieces. The two argument
$LENGTH() returns the number of existing pieces, while the one argument returns the number of characters.
• For a process started in UTF-8 mode, $LENGTH() interprets the string argument(s) as UTF-8 encoded. With VIEW
"BADCHAR" enabled, $LENGTH() produces a run-time error when it encounters a malformed character.
• $ZLENGTH() is the parallel function of $LENGTH(). Irrespective of the setting of VIEW "BADCHAR" and $ZCHSET,
$ZLENGTH() interpets string arguments as a sequence of bytes (rather than characters) and can perform all byte-oriented
$LENGTH() operations. For more information, refer to “$ZLength()” (page 269).
Examples of $LENGTH()
Example:
GTM>Write $length("KINGSTON")
8
GTM>
Functions
226
This uses $LENGTH() to WRITE the length in characters of the string "KINGSTON".
Example:
GTM>set x="Smith/John/M/124 Main Street/Ourtown/KA/USA"
GTM>write $length(x,"/")
7
GTM>
This uses $LENGTH() to WRITE the number of pieces in a string, as delimited by /.
Example:
GTM>write $length("/2/3/","/")
4
GTM>
This also uses $LENGTH() to WRITE the number of pieces in a string, as delimited by /. Notice that GT.M. adds one count to
the count of delimiters (in this case 3), to get the number of pieces in the string (displays 4).
$NAme()
Returns an evaluated representation of some or all of a local or global variable name.
The format for the $NAME function is:
$NA[ME](glvn[,intexpr])
• The subscripted or unsubscripted global or local variable name, including naked references, specifies the name for which
$NAME() returns an evaluated representation.
• When using NOUNDEF, $NAME() returns an empty string where appropriate for undefined variables.
• The optional integer expression (second argument) specifies the maximum number of subscript levels in the representation.
If the integer expression is not provided or exceeds the actual number of subscript levels, $NAME() returns a representation
of the whole name. If the integer expression is zero (0), $NAME() returns only the name. A negative integer expression
produces a run-time error.
Examples of $NAME()
Example:
GTM>set X="A""B",^Y(1,X,"B",4)=""
GTM>write $name(^(3),3)
^Y(1,"A""B","B")
GTM>
This example sets up a naked reference and then uses $NAME() to display the first three levels of that four-level reference.
Example:
GTM>write $name(^(3),0)
^Y
Functions
227
GTM>
This example shows the name level for the same naked reference.
$Next()
Returns the next subscripted local or global variable name in collation sequence within the array level specified by its
argument.
$NEXT() has been replaced by $ORDER(). $NEXT has been retained in the current standard only for compatibility with earlier
versions of the standard. $NEXT() is similar to $ORDER(). However, $NEXT() has the deficiency that when it encounters
negative one (-1) as a subscript, it returns the same result as when it finds no other data at the level. This deficiency is
particularly disruptive because it occurs in the middle of the M collating sequence.
Caution
As $NEXT() has been removed from the standard in the MDC, you should use $ORDER.
The format for the $NEXT function is:
$N[EXT](glvn)
• The subscripted global or local variable name specifies the node following which $NEXT() searches for the next node with
data and/or descendants; the number of subscripts contained in the argument implicitly defines the array level.
• If $NEXT() finds no node at the specified level after the specified global or local variable, it returns negative one (-1).
• If the last subscript in the subscripted global or local variable name is null or negative one (-1), $NEXT() returns the first node
at the specified level.
$Order()
Returns the subscript of the next or prior local or global variable name in collation sequence within the array level specified
by its first argument. In doing so, it moves in the direction specified by the second argument. In GT.M, when $ORDER() has an
unsubscripted argument, it returns the next or previous unsubscripted local or global variable name in collating sequence.
The format for the $ORDER function is:
$O[RDER](glvn[,expr])
• The subscripted global or local variable name specifies the node from which $ORDER() searches for the next or previous
node that has data and/or descendants. The number of subscripts contained in the argument implicitly defines the array level.
• The optional expression (second argument) specifies the direction for the $ORDER(); 1 specifies forward operation and -1
specifies reverse operation. Any other values for the expression will cause an error.
• GT.M extends the M standard to allow unsubscripted names. In this case, $ORDER() returns the next or previous
unsubscripted name.
• If $ORDER() finds no node (or name) at the specified level after (or before) the specified global or local variable, it returns an
empty string (" ").
Functions
228
• If the last subscript in the subscripted global or local variable name is null and the corresponding subscripted global or local
variable has a matching null subscript, $ORDER() returns the next node after that with the null subscript at the specified
level.
If the last subscript in the subscripted global or local variable name is null and the corresponding subscripted global or
local variable has no matching null subscript , $ORDER() returns first node at the specified level. If the last subscript in the
subscripted global or local variable name is null and second argument is -1, $ORDER() always returns the last node at the
specified level regardless of the existence a null subscript at the specified level. However when a global or local variable level
includes a null subscript and $ORDER(glvn,-1) returns an empty string result, users must test separately for the existence of
the node with the null subscript.
• $ORDER() can be used as a tool for retrieving data from M sparse arrays in an ordered fashion, independent of the order
in which it was entered. In M, routines generally sort by SETting data into an array with appropriate subscripts and then
retrieving the information with $ORDER().
• $ORDER() returns subscripts, not data values, and does not discriminate between nodes that have data values and nodes
that have descendants. Once $ORDER() provides the subscript, the routine must use the subscript to access the data value, if
appropriate. Using $ORDER() maintains the naked reference indicator, even if $ORDER() returns a null.
• GT.M optionally permits the use of null subscripts. This feature is enabled via the VIEW command for local variables and a
REGION qualifier in GDE for global variables. When an application uses null subscripts, they are "invisible" in a $ORDER()
loop so the application must test for them as a special case, perhaps using $DATA().
• $Order() returns local array subscripts with values that are numeric, but non-canonical (over 18 digit), as strings.
Note
Name-level $ORDER() always returns an empty string when used with extended references.
Examples of $ORDER()
Example:
GTM>zwrite
lcl(1)=3
lcl("x")=4
GTM>write $order(lcl(""))
1
This example returns the first node, that is 1, because the specified last subscript of the argument is null and lcl has no null
subscript.
Example:
GTM>write $order(lcl(1))
x
This example returns the first node after lcl(1) that is x because lcl has no null subscript.
Example:
GTM>write $order(lcl(""),-1)
x
Functions
229
This example returns the last node that is, x, because the last subscript of the first argument is null and second argument is -1.
GTM>set lcl("")=2
GTM>zwrite
lcl("")=2
lcl(1)=3
lcl("x")=4
GTM>write $order(lcl(""))
1
This example returns the second node at the specified level because the null subscript at the end of the argument is ambiguous
(does it specify starting at the beginning or starting at the real node with the null subscript?) and returning the subscript of the
first node (an empty string) would tend to create an endless loop.
Example:
GTM>write $order(lcl(""),-1)
x
GTM>write $order(lcl("x"),-1)
1
Example:
GTM>kill set (a(1),a(2000),a("CAT"),a("cat"),a("ALF"),a(12))=1
GTM>set x="" for set x=$order(a(x)) quit:x="" write !,x
1
12
2000
ALF
CAT
cat
GTM>kill a("CAT") set a(5,10)="woolworths",a("cat")="last"
GTM>set x="" for set x=$order(a(x),-1) quit:x="" write !,x
cat
ALF
2000
12
5
1
GTM>
This example uses a $ORDER() loop to display all the subscripts at the first level of local variable a, make some changes in a,
and then display all the subscripts in reverse order. Notice that $ORDER() returns only the existing subscripts in the sparse
array and returns them in M collation sequence, regardless of the order in which they were entered. Also, $ORDER() does not
differentiate between node A(5), which has only descendants (no data value), and the other nodes, which have data values.
Example:
GTM>kill set (%(1),tiva(2),A(3),tiv(4),Q(5),%a(6))=""
GTM>set x="%"
GTM>write:$data(@x) !,x for set x=$order(@x) quit:x="" write !,x
%
%a
A
Q
tiv
Functions
230
tiva
x
GTM>set $piece(x,"z",32)=""
GTM>write:$data(@x) !,x for set x=$order(@x,-1) quit:x="" write !,x
x
tiva
tiv
Q
A
%a
%
GTM>
This example uses $ORDER() to display the current local variable names in both forward and reverse order. Notice that the first
([^]%) and last ([^]zzzzzzzz) names require handling as special cases and require a $DATA() function.
Example:
 set acct="",cntt=""
 for fet acct=$order(^acct(acct)) quit:acct="" do
 . for set cntt=$order(^acct(acct,cntt)) do WORK
 quit
This uses two nested $ORDER() loops to cycle through the ^acct global array and perform some action for each second level
node.
$Piece()
Returns a substring delimited by a specified string delimiter made up of one or more characters. In M, $PIECE() returns a logical
field from a logical record.
The format for the $PIECE function is:
$P[IECE](expr1,expr2[,intexpr1[,intexpr2]])
• The first expression specifies the string from which $PIECE() computes its result.
• The second expression specifies the delimiting string that determines the piece "boundaries"; if this argument is an empty
string, $PIECE() returns an empty string.
• If the second expression does not appear anywhere in the first expression, $PIECE() returns the entire first expression (unless
forced to return an empty string by the second integer expression).
• The optional first integer expression (third argument) specifies the beginning piece to return; if this argument is missing,
$PIECE() returns the first piece.
• The optional second integer expression (fourth argument) specifies the last piece to return. If this argument is missing,
$PIECE() returns only one piece unless the first integer expression is zero (0) or negative, in which case it returns a null
string. If this argument is less than the first integer expression, $PIECE() returns an empty string.
• If the second integer expression exceeds the actual number of pieces in the first expression, $PIECE() returns all of the
expression after the delimiter selected by the first integer expression.
• The $PIECE() result never includes the "outside" delimiters; however, when the second integer argument specifies multiple
pieces, the result contains the "inside" occurrences of the delimiter.
Functions
231
• $PIECE() can also be used as tool for efficiently using values that contain multiple elements or fields, each of which may be
variable in length.
• Applications typically use a single character for a $PIECE() delimiter (second argument) to minimize storage overhead,
and increase efficiency at run-time. The delimiter must be chosen so the data values never contain the delimiter. Failure
to enforce this convention with edit checks may result in unanticipated changes in the position of pieces within the data
value. The caret symbol (^), backward slash (\), and asterisk (*) characters are examples of popular visible delimiters. Multiple
character delimiters may reduce the likelihood of conflict with field contents. However, they decrease storage efficiency, and
are processed with less efficiency than single character delimiters. Some applications use control characters, which reduce
the chances of the delimiter appearing in the data but sacrifice the readability provided by visible delimiters.
• A SET command argument can have something that has the format of a $PIECE() on the left-hand side of its equal sign
(=). This construct permits easy maintenance of individual pieces within a string. It also can be used to generate a string of
delimiters. For more information on SET $PIECE(), refer to “Set” (page 143).
• $PIECE() can also be used as target in a SET command to change part of the value of a node. Also, when SET arguments
have multiple parenthesized (set-left) targets and a target is used as a subscript in more than one item in the list of targets
that follow, all the targets use the before-SET value (not the after-SET value) in conformance to the M-standard. For more
information on SET $PIECE(), refer to “Set” (page 143).
• For a proces started in UTF-8 mode, $PIECE() interprets the string arguments as UTF-8 encoded. With VIEW "BADCHAR"
enabled, $PIECE() produces a run-time error when it encounters a malformed character, but it does not process the characters
that fall after the span specified by the arguments.
• $ZPIECE() is the parallel function of $PIECE(). Irrespective of the settings of VIEW "BADCHAR" and $ZCHSET, $ZPIECE()
interprets string arguments as a sequence of bytes (rather than a sequence of characters) and can perform all byte-oriented
$PIECE() operations. For more information, refer to “$ZPIece()” (page 272).
Examples of $PIECE()
Example:
GTM>for i=0:1:3 write !,$piece("1 2"," ",i),"<"
<
1<
2<
<
GTM>
This loop displays the result of $PIECE(), specifying a space as a delimiter, a piece position "before," first and second, and "after"
the string.
Example:
GTM>for i=-1:1:3 write !,$piece("1 2"," ",i,i+1),"<"
<
1<
1 2<
2<
<
GTM>
This example is similar to the previous example except that it displays two pieces on each iteration. Notice the delimiter (a
space) in the middle of the output for the third iteration, which displays both pieces.
Functions
232
Example:
for p=1:1:$length(x,"/") write ?p-1*10,$piece(x,"/",p)
This example uses $LENGTH() and $PIECE() to display all the pieces of x in columnar format.
Example:
GTM>set $piece(x,".",25)="" write x
........................
This SETs the 25th piece of the variable x to null, with a delimiter of a period. This produces a string of 24 periods preceding the
null.
Example:
GTM>set ^x=1,$piece(^a,";",3,2)=^b
This example leaves the naked indicator to pointing to the global ^b.
$Qlength()
Returns the number of subscripts in a variable name. The format is:
$QL[ENGTH] (namevalue)
• The namevalue has the form of an evaluated subscripted or unsubscripted global variable.
• $QLENGTH() returns a value which is derived from namevalue. If namevalue has the form NAME(s1, s2,..., sn), then the
function returns n; if the name is unsubscripted, $QLENGTH() yields a length of zero (0).
• $QLENGTH() only affects the naked indicator if the string in question is stored in a global variable.
Examples of $QLENGTH()
Example:
GTM>write $data(^|"XXX"|ABC(1,2,3,4))
0
GTM>set X=$name(^(5,6))
GTM>write $qlength(X)
5
The number of subscripts in x is 5. Notice that the name and the environment preceding it do not contribute to the count. Refer
to $NAme() section earlier in this chapter for an understanding of the $NAME function.
$QSubscript()
Returns a component of a variable name.
The format of the $QSUBSCRIPT function is:
$QS[UBSCRIPT](namevalue, intexpr)
• The namevalue has the form of an evaluated subscripted or unsubscripted global or local variable name.
Functions
233
• The intexpr selects the component of the name as follows:
• -2 : is reserved but may be "error",
• -1 : for environment,
• 0 : for the unsubscripted name,
• 1 : for the first subscript,
• 2 : for the second subscript, and so on.
• If the second argument selects a component that is not part of the specified name, $QSUBSCRIPT() returns an empty string
("").
Examples of $QSUBSCRIPT()
Example:
Assume that X is defined as in the "Examples of $Qlength()" earlier in this chapter;
write X
X="^|""XXX""|ABC(1,2,3,5,6)"
GTM>write $qsubscript(X,-2)
error
GTM>WRITE $qsubscript(X,-1)
XXX
GTM>WRITE $qsubscript(X,0)
^ABC
GTM>WRITE $qsubscript(X,1)
1
GTM>WRITE $qsubscript(X,4)
5
GTM>WRITE $qsubscript(X,7)
""
$Query()
Returns the next subscripted local or global variable node name, independent of level, which follows the node specified by its
argument in M collating sequence and has a data value.
The format for the $QUERY function is:
$Q[UERY](glvn)
• The subscripted or unsubscripted global or local variable name specifies the starting node from which $QUERY() searches for
a node with a data value.
• If $QUERY() finds no node after the specified global or local variable, it returns an empty string.
• With stdnullcoll, if $Data(glvn(""))=1 (or 11), $Query(glvn("")) returns glvn(1) (assuming glvn(1) exists). Applications looking
for a node with a "null" subscript must use $D(glvn("")) to test the existence of glvn(""). $Q(glvn("...")) never returns the
starting-point (glvn("")) even though glvn("") may exist.
Functions
234
$QUERY() can be used as a tool for scanning an entire array for nodes that have data values. Because $QUERY() can return a
result specifying a different level than its argument, the result provides a full variable name. This contrasts with $ORDER(),
which returns a subscript value. To access the data value at a node, a $ORDER() return can be used as a subscript; however,
a $QUERY() return must be used with indirection. Because arrays tend to have homogeneous values within a level but not
between levels, $QUERY() is more useful as a tool in utility programs than in application programs. The $QUERY() can be useful
in avoiding nested $ORDER loops.
Note that the standard does not unambiguously define the state of the naked reference indicator after a $QUERY(). While in
GT.M after $QUERY(), the naked reference indicator reflects the $QUERY() argument, NOT its result.
Examples of $QUERY()
Example:
set ^X(1,2,3)="123"
set ^X(1,2,3,7)="1237"
set ^X(1,2,4)="124"
set ^X(1,2,5,9)="1259"
set ^X(1,6)="16"
set ^X("B",1)="AB"
The tree diagram below represents the structure produced by the preceding routine.
The following routine:
set y="^X"
for set y=$query(@y) quit:y="" write !,y,"=",@y
produces the results:
^X(1,2,3)=123
^X(1,2,3,7)=1237
^X(1,2,4)=124
^X(1,2,5,9)=1259
^X(1,6)=16
^X("B",1)=AB
Example:
GTM>zwrite lcl
Functions
235
lcl("")=1
lcl(1)=1
lcl(1,2)=2
lcl(1,2,"")=3
lcl(1,2,"","")=4
lcl(1,2,"","",4)=5
lcl(1,2,0)=6
lcl(1,2,"abc",5)=7
lcl("x")=1
GTM>set y="lcl"
GTM>for set y=$query(@y) quit:y="" write !,y,"=",@y
This example produces the results:
lcl("")=1
lcl(1)=1
lcl(1,2)=2
lcl(1,2,"")=3
lcl(1,2,"","")=4
lcl(1,2,"","",4)=5
lcl(1,2,0)=6
lcl(1,2,"abc",5)=7
lcl("x")=1
Note that the result is the same as the ZWRITE output.
$Random()
Returns a random integer from a range specified by its argument.
The format for the $RANDOM function is:
$R[ANDOM](intexpr)
• The integer expression specifies the upper exclusive limit of a range of integers from which $RANDOM() may pick a result;
$RANDOM() never returns a number less than zero (0).
• If $RANDOM() has an argument less than one (1), it generates a run-time error.
• $RANDOM can generate numbers up to 2147483646 (that is 2GB - 2).
$RANDOM() provides a tool for generating pseudo-random patterns useful in testing or statistical calculations. $RANDOM()
results fall between zero (0) and one less than the argument.
Random number generators use factors from the environment to create sequences of numbers. True random number generation
requires a source of what is known as "noise". Pseudo-random numbers appear to have no pattern, but are developed using
interactions between factors that vary in ways not guaranteed to be entirely random. In accordance with the M standard, the
GT.M implementation of $RANDOM() produces pseudo-random numbers.
Examples of $RANDOM()
Example:
GTM>for i=1:1:10 write $random(1)
Functions
236
0000000000
GTM>
This shows that when $RANDOM() has an argument of one (1), the result is too confined to be random.
Example:
set x=$random(100)+1*.01
This $RANDOM() example produces a number between 0 and 99. The example then shifts with addition, and scales with
multiplication to create a value between .01 and 1.
$REverse()
Returns a string with the characters in the reverse order from that of its argument.
The format for the $REVERSE function is:
$RE[VERSE](expr)
• The expr in the syntax is the string to be reversed.
Examples of $REVERSE()
Example:
GTM>write $reverse(123)
321
GTM>write $reverse("AbCDe")
"eDCbA"
$Select()
Returns a value associated with the first true truth-valued expression in a list of paired expression arguments.
The format for the $SELECT function is:
$S[ELECT](tvexpr:expr[,...])
• $SELECT() evaluates expressions from left to right.
• If a truth-valued expression is TRUE (1), $SELECT() returns the corresponding expression after the colon (:) delimiter.
• Once $SELECT() finds a TRUE, the function does not process any remaining arguments.
• If $SELECT() finds no TRUE truth-value in its list of arguments, the function generates a run-time error.
• $SELECT() does not have any effect on $TEST.
$SELECT() is one of a limited set of functions that permit an indefinite number of arguments. $SELECT() provides a means of
selecting from a list of alternatives.
Generally, the last $SELECT() argument has numeric literal one (1) for a truth-value to prevent run-time errors, and to provide
a "default" value.
Functions
237
Examples of $SELECT()
Example:
GTM>for i=3:-1:0 write !,$select(i=1:"here",i=2:"come",i=3:"Watson")
Watson
come
here
%GTM-E-SELECTFALSE, No argument to $SELECT was true
GTM>
This loop uses $SELECT() to WRITE a series of strings. Because there is no true argument on the fourth iteration, when i=0,
$SELECT() produces an error.
Example:
set name=$select(sex="M":"Mr. ",sex="F":"Ms. ",1:"")_name
This example uses $SELECT() to add a prefix to the name based on a sex code held in the variable sex. Notice that the default
handles the case of a missing or incorrect code.
Example:
if $select(x=+x:x,x="":0,"JANAPRJULOCT"[x:1,1:0) do THING
This uses $SELECT() to perform complex logic as the truth-valued expression argument to an IF command.
$STack()
Returns strings describing aspects of the execution environment.
The format for the $STACK function is:
$ST[ACK](intexpr[,expr])
• The intexpr identifies the M virtual machine stack level (as described by the standard), on which the function is to provide
information.
• The optional second argument is evaluated as a keyword that specifies a type of information to be returned as follows:
• "MCODE" the line of code that was executed.
• "PLACE" the address of the above line of code or the symbol at ("@") to indicate code executed from a string value.
Note
For run-time errors, GT.M does not provide a "PLACE" within a line (unlike it does for compilation errors),
but it reports a label, offset, and routine.
• "ECODE" either an empty string, or the error code(s) that was added at this execution level.
• When $STACK has only one argument, values corresponding to available stack levels specify a return value that indicates
how the level was created, as follows:
• If intexpr is zero (0), the function returns information on how GT.M was invoked.
Functions
238
• If intexpr is minus one (-1), the function returns the highest level for which $STACK can return information. Note that, if
$ECODE="", $STACK(-1) returns the same value as the $STACK ISV.
• If intexpr is greater than zero (0) and less than or equal to $STACK(-1), indicates how this level of process stack was created
("DO", "TRIGGER" - for a stack level invoked by a trigger, "XECUTE", or "$$" - for an extrinsic function).
• $STACK(lvl) reports "ZINTR" for a stack level invoked by MUPIP INTRPT.
• If intexpr is greater than $STACK (-1), the function returns an empty string.
• During error handling, $STACK() return a snapshot of the state of the stack at the time of error. Even if subsequent actions
add stack levels, $STACK() continues to report the same snapshot for the levels as of the time of the error. $STACK() reports
the latest stack information only after the code clears $ECODE.
• $STACK() assists in debugging programs.
Note
$STACK() returns similar information to ZSHOW "S" when ""=$ECODE, but when $ECODE contains
error information, $STACK() returns information as of the time of a prior error, generally the first entry
in $ECODE. For $STACK() to return current information, be sure that error handing code does a SET
$ECODE="" before restoring the normal flow of control.
Examples of $STACK()
Example:
/usr/lib/fis-gtm/V5.4-002B_x86/gtm -run ^dstackex
dstackex;
 zprint ^dstackex
 write !,$STACK
 xecute "WRITE !,$STACK"
 do Label
 write !,$$ELabel
 write !,$STACK
 quit
Label
 write !,$STACK
 do DLabel
 quit
ELabel()
 quit $STACK
DLabel
 write !,$STACK
 quit
0
1
1
2
1
Functions
239
Example for error processing:
GTM>zprint ^debugerr
debugerr;
 set dsm1=$stack(-1)
 write !,"$stack(-1):",dsm1
 for l=dsm1:-1:0 do
 . write !,l
 . for i="ecode","place","mcode" write ?5,i,?15,$stack(l,i),!
GTM>
The above example can be used to display a trace of the code path that led to an error.
Example:
GTM>zprint ^dstacktst
dstacktst(x) ; check $stack() returns with and without clearing $ecode
 set $etrap="do ^debugerr"
label
 if x>0 set $ecode=",U1," ; if condition
 else set $ecode=",U2," ; else condition
 quit
GTM>do ^dstacktst(0)
$stack(-1):2
2 ecode
 place debugerr+3^debugerr
 mcode for l=dsm1:-1:0 do
1 ecode ,U2,
 place label+2^dstacktst
 mcode else set $ecode=",U2," ; else condition
0 ecode
 place +1^GTM$DMOD
 mcode
%GTM-E-SETECODE, Non-empty value assigned to $ECODE (user-defined error trap)
GTM>do ^dstacktst(1)
$stack(-1):1
1 ecode ,U2,
 place label+2^dstacktst
 mcode else set $ecode=",U2," ; else condition
0 ecode
 place +1^GTM$DMOD
 mcode
%GTM-E-SETECODE, Non-empty value assigned to $ECODE (user-defined error trap)
GTM>set $ecode=""
GTM>do ^dstacktst(1)
$stack(-1):2
2 ecode
 place debugerr+3^debugerr
 mcode for l=dsm1:-1:0 do
1 ecode ,U1,
 place label+1^dstacktst
 mcode if x>0 set $ecode=",U1," ; if condition
0 ecode
 place +1^GTM$DMOD
 mcode
%GTM-E-SETECODE, Non-empty value assigned to $ECODE (user-defined error trap)
Functions
240
GTM>
This example shows how SETing $ECODE=.. makes $STACK() reports current information. Notice how ^do dstacktst(0) and
^dostacktst(1) without clearing $ECODE in between displays information frozen at the time of the first error (else condition).
$Text()
Returns source text for the line specified by its argument.
The format for the $TEXT function is:
$T[EXT](entryref)
• The entryref specifies the label, offset, and routine (or trigger name) of the source line that $TEXT() returns.
• If the label+offset combination do not fall within the routine, $TEXT returns a null string.
• If the entryref explicitly or implicitly specifies an offset of zero (0) from the beginning of the routine (or trigger name),
$TEXT() returns the routine name or trigger name.
• If the entryref does not specify a routine/trigger, GT.M assumes the current routine/trigger, that is, the routine/trigger at the
top of a ZSHOW "S."
• A GT.M extension to $TEXT() permits negative offsets; however, every offset must still be preceded by a plus sign (+)
delimiter, (for example, LABEL+-3). If a negative offset points to a line prior to the zero line, $TEXT() generates a run-time
error.
$TEXT() provides a tool for examining routine source code and the name of the current routine or trigger. $TEXT() assists,
along with the ZPRINT command, in debugging programs. $TEXT() also allows the insertion of small tables of driver
information into a routine. Because $TEXT() is not very efficient and the table-driven technique is generally best suited to
minimal program changes, this approach is best used for prototyping and the tables should reside in global variables for
production.
If $TEXT() cannot access the source file for the current object, either because it is not in the location from which it was
compiled or because the process does not have access to some piece of the path to the source, or if the located source does not
match the object currently in use by the process, $TEXT() returns an empty string.
Examples of $TEXT()
Example:
for i=1:1 set x=$text(+i) quit:x="" write !,x
This loop uses $TEXT() to write out the entire source for the current routine.
Example:
GTM>write $text(+0)
GTM$DMOD
GTM>write $text(+1)
GTM>
Functions
241
This uses $TEXT() to WRITE the name of the current routine, then it tries to access the source and returns an empty string.
This occurs because the default Direct Mode image is compiled by FIS and delivered without source. The exact failure message
may vary.
$TRanslate()
Returns a string that results from replacing or dropping characters in the first of its arguments as specified by the patterns of its
other arguments.
The format for the $TRANSLATE function is:
$TR[ANSLATE](expr1[,expr2[,expr3]])
• The first expression specifies the string on which $TRANSLATE() operates. If the other arguments are omitted,
$TRANSLATE() returns this expression.
• The optional second expression specifies the characters for $TRANSLATE() to replace. If a character occurs more than once
in the second expression, the first occurrence controls the translation, and $TRANSLATE() ignores subsequent occurrences. If
this argument is omitted, $TRANSLATE() returns the first expression without modification.
• The optional third expression specifies the replacement characters for positionally corresponding characters in the second
expression. If this argument is omitted or shorter than the second expression, $TRANSLATE() drops all occurrences of
characters in the second expression that have no replacement in the corresponding position of the third expression.
• For a process started in UTF-8 mode, the algorithm of $TRANSLATE() treats the string arguments as UTF-8 encoded. With
VIEW "BADCHAR" enabled, $TRANSLATE() produces a run-time error when it encounters a malformed character.
• Irrespective of the settings of VIEW "BADCHAR" and $ZCHSET, $ZTRANSLATE() interprets argument as a sequence
of bytes (rather than a sequence of characters) and performs all byte-oriented $TRANSLATE() operations. For more
information, refer to “$ZTRanslate()” (page 284).
• $TRANSLATE() provides a tool for tasks such as changing case and doing encryption. For examples of case translation, refer
to the ^%LCASE and ^%UCASE utility routines.
The $TRANSLATE() algorithm can be understood as follows:
• $TRANSLATE() evaluates each character in the first expression, comparing it character by character to the second expression
looking for a match. If there is no match in the second expression, the resulting expression contains the character without
modification.
• When it locates a character match, $TRANSLATE() uses the position of the match in the second expression to identify the
appropriate replacement for the original expression. If the second expression has more characters than the third expression,
$TRANSLATE() replaces the original character with a null, thereby deleting it from the result. By extension of this principle,
if the third expression is missing, $TRANSLATE() deletes all characters from the first expression that occur in the second
expression.
Examples of $TRANSLATE()
Example:
GTM>write $translate("ABC","CB","1")
Functions
242
A1
GTM>
• First, $TRANSLATE() searches for "A" (the first character in the first expression, "ABC") within the second expression ("CB").
Since "A" does not exist in the second expression, it appears unchanged in the result.
• Next, $TRANSLATE() searches for "B" (the second character in the first expression) within the second expression ("CB").
Because "B" holds the second position in the second expression ("CB"), $TRANSLATE() searches for the character holding the
second position in the third expression. Since there is no second character in the third expression, $TRANSLATE() replaces
"B" with a null, effectively deleting it from the result.
• Finally, $TRANSLATE() searches for "C" (the third character in the first expression) within the second expression ("CB"),
finds it in the first position, and replaces it with the number 1, which is in the first position of the third expression. The
translated result is "A1."
Note
While this example provides an explanation for the work done by $TRANSLATE(), it does not necessarily
correspond to how GT.M implements $TRANSLATE().
Example:
GTM>write $translate("A","AA","BC")
B
GTM>
This $TRANSLATE() example finds the first occurrence of "A" in the second expression, which holds the first character
position, and substitutes the character in the first position of the third expression.
Example:
GTM>write $translate("BACKUP","AEIOU")
BCKP
GTM>
Because the $TRANSLATE() has only two parameters in this example, it finds the characters in the first expression that also
exist in the second expression and deletes them from the result.
$View()
Returns information about an environmental factor selected by the arguments. In GT.M, the first argument contains a keyword
identifying the environmental factor and, where appropriate, subsequent arguments select among multiple possible occurrences
of that factor.
The format for the $VIEW() function is:
$V[IEW](expr1[,expr2])
• The first expression specifies a keyword identifying the target factor for $VIEW() to examine.
• The second expression differentiates between multiple possible targets for some keywords. $VIEW() requires the second
expression for some keywords and does not permit it for others.
Functions
243
Argument Keywords of $VIEW()
$VIEW() provides a means to access GT.M environmental information. When GT.M permits modification of the factors
accessible with $VIEW(), the VIEW command generally provides the means for effecting the change.
$VIEW() Argument Keywords
ARG 1 ARG 2 RETURN VALUE
"BADCHAR" none In UTF-8 mode processes, enables or disable the generation of an
error when character-oriented functions encounter malformed byte
sequences (illegal characters). The default is 1.
"BREAKMSG" none Value of the break message mask; GT.M defaults this to 31.
"DEVICE" Device name Device type (FIFO, NULL, PIPE, RMS, SOCKET, or TERMINAL) and
device status (OPEN or CLOSED) separated by a colon (":")
"FREEBLOCKS" region Number of free database blocks in a given region.
"FREEZE" region Process-id of a process that has frozen the database associated with
the region specified (using DSE or MUPIP).
If the region is currently not frozen, returns zero.
"FULL_BOOLEAN" none Returns a string describing the current compiler setting. The
default is "GT.M Boolean short-circuit". $VIEW("FULL_BOOLEAN")
reports "Standard Boolean evaluation side effects" when it is
not explicitly set, but that mode of operation is required by the
setting of gtm_side_effects, and "Standard Boolean side-effect
warning" when warnings have been specified. The function reports
"Extended Boolean evaluation without short-circuiting" when
"EXTENDED_BOOLEAN" behavior is enabled.
"GDSCERT" none Truth Value indicating whether Database block certification is
currently enabled or disabled.
To enable or disable Database block certification, use the VIEW
"GDSCERT" command.
"GVACCESS_METHOD" region Access method of the region.
"GVFILE" region Name of the database associated with the region.
"GVFIRST" none Name of the first database region in the current global directory;
functionally equivalent to $VIEW("GVNEXT","").
"GVNEXT" region Name of the next database region after the given one in alphabetical
order (or M collation sequence); "" for region starts with the first
region. A return value of "" means that the global directory defines
no additional regions.
"GVSTAT" region A read-only process cannot update the database including the
database file header where GVSTATS are stored. Another process
with write access to a database, such as MUPIP RUNDOWN, can
flush its read statistics from the associated shared memory to
GVSTATS.
"ICHITS" none Number of indirection cache hits since GT.M process startup.
Functions
244
$VIEW() Argument Keywords
ARG 1 ARG 2 RETURN VALUE
Indirection cache is a pool of compiled expressions that GT.M
maintains for indirection and XECUTE.
"ICMISS" none Number of indirection cache misses since GT.M process startup.
"JNLACTIVE" region can return the following values:
• -1 (internal error)
• 0 journaling is disabled
• 1 journaling is enabled but closed (OFF)
• 2 journaling is enabled and open (ON)
"JNLFILE" region Journal file name associated with the region.
"JNLPOOL" none Returns the replication instance file name for the current Journal
Pool and an empty string when there is no Journal Pool. Note that
the current Journal Pool may not be associated with the last global
accessed by an extended reference.
"JNLTRANSACTION" none Index showing how many ZTSTART transaction fences have been
opened (and not closed).
"LABELS" none Truth value showing whether label case sensitivity is ON (1 for
"LOWER") or OFF (0 for "UPPER"); GT.M defaults to 1.
"LINK" none Returns the current relink recursive setting of ZLINK.
"LV_CREF" local variable name (lvn) returns the number of references by alias containers to the array
associated with an unsubscripted local variable name specified as
a second expr (for example a quoted string); it returns a zero for a
variable without any associated alias container.
"LV_GCOL" none returns the number of data-spaces recovered during a local variable
data-space garbage collection it triggers; such collections normally
happen automatically at appropriate times.
"LV_REF" local variable name (lvn) returns the total number of references to the data-space associated
with an unsubscripted local variable name specified as a second
expr (for example a quoted string).
"LVNULLSUBS" none Truth value showing whether null subscripts are permitted in local
arrays (1 for "LVNULLSUBS") or not (0 for "NOLVNULLSUBS");
GT.M defaults to 1.
"NOISOLATION" global The current isolation-status of the specified global variable which
must have a leading "^" in its specification.
This function returns 1 if GT.M has been instructed to not enforce
the ACID property of Isolation (that is, "NOISOLATION" has been
specified) and 0 otherwise.
Functions
245
$VIEW() Argument Keywords
ARG 1 ARG 2 RETURN VALUE
By default, GT.M ensures Isolation, that is, a $VIEW command will
return 0. The isolation-status of a global variable can be turned on
and off by the VIEW "NOISOLATION" command.
"PATCODE" none Name of the active patcode table; GT.M defaults this to "M".
"POOLLIMIT" region The current limit on global buffers for the region .
"PROBECRIT" region Acquires and releases a critical section for the region (the "probe"),
returning a string containing following fields, some of of which
always have zero (0) values because they are no longer used:
• CPT - nanoseconds for the probe to get the critical section
• CFN - 0
• CQN - 0
• CYN - 0
• CQF - 0
• CQE - 0
• CAT - total of critical section acquisitions successes
"REGION" gvn Name of the region(s) holding the specified gvn.
If gvn spans more than one region, this function returns region
name in an order where the first region is the region to which the
unsubscripted global variable name maps; and other regions are in
the order in which they would be encountered by traversing the
subscripts of gvn in order (with duplicates removed).
gvn is a subscripted or unsubscripted global variable name in the
same form as that generated by $NAME(). You can use $NAME()
inside $VIEW() to ensure that subscripts are in a correct form,
for example, $VIEW("REGION",$NAME(^abcd(1,2E4))) instead of
$VIEW("REGION","^abcd(1,20000)").
"RTNCHECKSUM" routine name Source code check-sum for the most recently ZLINK'd version of
the specified routine name (these check-sums use a 128 bit hash
based on the MurmurHash3 algorithm).
"RTNNEXT" routine name Name of the next routine in the image after the given one; "" (empty
string) for routinename starts with the first routine in ASCII
collating sequence and a return value of the empty string indicates
the end of the list.
"SPSIZE" none Returns a string with three comma separated values: Number
of bytes currently allocated as process working storage: GT.M
manages this space as what is commonly called a heap, and uses the
term stringpool to refer to it. The GT.M garbage collector reclaims
unused space from the stringpool from time to time, and GT.M
automatically expands the stringpool as needed by the application
Functions
246
$VIEW() Argument Keywords
ARG 1 ARG 2 RETURN VALUE
program; Number of bytes currently used by the process; Number
of bytes reserved: The reserved space is used to reduce the active
memory usage, for example, when a process uses a large amount of
memory then subsequently uses a significantly reduced amount.
"STATSHARE" region Returns 0 when the process has sharing disabled, 1 when it
has sharing enabled, and 2 when sharing is enabled selectively
for regions. For a process to store statistics in the stats db,
the database must be enabled for sharing and the process
must have opted in to share. VIEW "STATSHARE" with no
region argument enables sharing for all regions and VIEW
"STATSHARE":"REGION_NAME" enables sharing selectively for a
region. $VIEW("STATSHARE","REGION_NAME") returns whether
a process has opted to share statistics for a region.
"STKSIZ" none Returns the GT.M stack size in bytes.
"TOTALBLOCKS" region Total number of database blocks in a given region.
"TRANSACTIONID" NULL
or
transaction level
Transaction ID specified in the particular level (when the
transaction level is specified). The first level TSTART is returned if
the level is not specified as second argument.
Note
A NULL string is returned if the specified level
(explicitly or implicitly) is greater than the
current value of $TLEVEL.
"UNDEF" none Truth value showing whether undefined variables should be treated
as having a null value (1 for "UNDEF"; 0 for "NOUNDEF"); GT.M
defaults to 0.
"ZDATE_FORM" none Integer value showing whether four digit year code is active
for $ZDATE(); GT.M defaults to 0 (for "YY" format). Use the
environment variable gtm_zdate_form to set the initial value of this
factor. For usage examples, refer to “$ZDate()” (page 261).
Important
FIS uses the LC_CREF, LV_GCOL, LV_REF keywords in testing and is documenting them to ensure
completeness in product documentation. They may (or may not) be useful during application development
for debugging or performance testing implementation alternatives.
Examples of $VIEW()
Example:
GTM>Set a=1,*b(1)=a
GTM>write $view("LV_CREF","a")," ",$view("LV_CREF","b")
Functions
247
1 0
GTM>write $view("LV_REF","a")," ",$view("LV_REF","b")
2 1
GTM>
This example creates an alias variable and an alias container variable and checks the number of both container references and
total references to the cells associated with both a and b.
Example:
GTM>Set *a(1)=b,*b(1)=a
GTM>kill *a,*b
GTM>write $view("LV_GCOL")
2
GTM>
This example creates two cross associated alias containers, destroys their ancestor nodes with KILL * and uses
$VIEW("LV_GCOL") to force a clean-up of the abandoned data-spaces. In the absence of the $VIEW("LV_GCOL"), GT.M would
do this automatically at some subsequent convenient time.
Example:
GTM>write $view("GVSTAT","DEFAULT")
SET:203,KIL:12,GET:203,DTA:2,ORD:23,ZPR:21,QRY:0,LKS:0,LKF:0,CTN:44,DRD:103,DWT:59,
NTW:24,NTR:55,NBW:27,NBR:138,NR0:0,NR1:0,NR2:0,NR3:0,TTW:17,TTR:5,TRB:0,TBW:32,
TBR:80,TR0:0,TR1:0,TR2:0,TR3:0,TR4:0,TC0:0,TC1:0,TC2:0,TC3:0,TC4:0,ZTR:7,DFL:9,
DFS:0,JFL:0,JFS:0,JBB:0,JFB:0,JFW:0,JRL:0,JRP:0,JRE:0,JRI:0,JRO:0,JEX:0,DEX:0,
CAT:35,CFE:0,CFS:0,CFT:0,CQS:0,CQT:0,CYS:0,CYT:0,BTD:13
GTM>
These are statistics associated with the DEFAULT region. Refer to “ZSHOW Information Codes” (page 192) for information on
the parameters.
Example:
Given the following global directory configuration:
GDE>add -name a(1:10) -region=a1
GDE>add -name a(10,1) -region=a2
GDE>add -name a(10,2) -region=a3
GDE>add -name a(120:300) -region=a4
GDE>add -name a(60:325) -region=a5
GDE> show -name
 *** NAMES ***
 Global Region
 ------------------------------------------------------------------------------
 * DEFAULT
 a(1:10) A1
 a(10,1) A2
 a(10,2) A3
 a(60:120) A5
 a(120:300) A4
 a(300:325) A5
Here are some $VIEW("REGION",gvn) outputs:
GTM>write $view("REGION","^a(1)")
A1
Functions
248
GTM>write $view("REGION","^a(10)")
DEFAULT,A2,A3
GTM>w $view("REGION","^a(60)")
A5
GTM>w $view("REGION","^a")
DEFAULT,A1,A2,A3,A5,A4
Some examples of $VIEW("DEVICE",name) usage:
GTM> WRITE $VIEW("DEVICE","0")
TERMINAL:OPEN
This indicates the $PRINCIPAL device is a terminal and it is open (which is usually the case for $PRINCIPAL.) The $ZPIN and
$ZPOUT intrinsic special variables can be used as the device name to select to corresponding side of a split $PRINCIPAL device.
GTM> OPEN "f.txt"
GTM> CLOSE "f.txt":NODESTROY
GTM> WRITE $VIEW("DEVICE","f.txt")
RMS:CLOSED
$ZAHandle()
$ZAHANDLE() returns a unique identifier (handle) for the array associated with a name or an alias container; for an
subscripted lvn, it returns an empty string. To facilitate debugging, the handle is a printable string representation of a
hexadecimal number. The only meaningful operation on the value returned by a call to $ZAHANDLE() is to compare it for
equality with the value returned by another call. Changing nodes within the array doesn't change its handle. $ZAHANDLE()
returns different results for copies of an array.
Example:
GTM>set A=1,*B(1)=A
GTM>write "$zahandle(A)=""",$zahandle(A),""" $zahandle(B(1))=""",$zahandle(B(1)),""""
$zahandle(A)="17B8810" $zahandle(B(1))="17B8810"
GTM>set A("Subscript")="Value" ; Change array - but $ZAHandle() doesn't change
GTM>write "$zahandle(A)=""",$zahandle(A),""" $zahandle(B(1))=""",$zahandle(B(1)),""""
$zahandle(A)="17B8810" $zahandle(B(1))="17B8810"
GTM>merge D=A ; A copy of the data has a different $zahandle()
GTM>Write "$ZAHandle(A)=""",$ZAHandle(A),""" $ZAHandle(D)=""",$ZAHandle(D),""""
$zahandle(A)="17B8810" $zahandle(D)="17B8C10"
GTM>
Since GT.M does not provide a way for a function to return an array or alias variable as its result, the uniqueness of
$ZAHandle() can be exploited to effect this capability, by placing the result in a local variable with an agreed prefix (e.g., "%")
and its $ZAHANDLE() as a suffix. The handle can be returned as the value.
$ /usr/lib/fis-gtm/V5.4-002B_x86/gtm -run retval
retval ; Return an array / object from a function
 ;;Data for the object array
 ;;Albert Einstein,14-March-1879
 ;;Arthur Eddington,28-December-1882
 ;;
 zprint ; Print this program
 new tmp1,tmp2,tmp3
 for i=3:1 set tmp1=$text(+i),tmp2=$piece(tmp1,";;",2) quit:'$length(tmp2) do
 .set tmp3="%"_$$NewPerson($piece(tmp2,",",1),$piece(tmp2,",",2))
 .set @("*Relativists("_(i-2)_")="_tmp3)
Functions
249
 .kill @("*"_tmp3)
 kill tmp1,tmp2,tmp3
 write "------------",!
 write "Array of objects of relativists:",!
 zwrite
 quit
 ;
NewPerson(name,birthdate) ; Create new person object
 new lname,fname,dob,tmp1,tmp2 ; New variables used by this function
 set lname=$Piece(name," ",2),fname=$Piece(name," ",1)
 set dob=$$FUNC^%DATE(birthdate)
 set tmp1("fname")=fname,tmp1("lname")=lname,tmp1("dob")=dob
 set tmp2=$ZAHandle(tmp1)
 set @("*%"_tmp2_"=tmp1")
 quit tmp2
------------
Array of objects of relativists:
$ZWRTAC=""
*Relativists(1)=$ZWRTAC1
$ZWRTAC1("dob")=13952
$ZWRTAC1("fname")="Albert"
$ZWRTAC1("lname")="Einstein"
*Relativists(2)=$ZWRTAC2
$ZWRTAC2("dob")=15337
$ZWRTAC2("fname")="Arthur"
$ZWRTAC2("lname")="Eddington"
i=5
$ZWRTAC=""
$
$ZAscii()
Returns the numeric byte value (0 through 255) of a given sequence of octets (8-bit bytes).
The format for the $ASCII function is:
$ZA[SCII](expr[,intexpr])
• The expression is the sequence of octets (8-bit bytes) from which $ZASCII() extracts the byte it decodes.
• The optional integer expression contains the position within the expression of the byte that $ZASCII() decodes. If this
argument is missing, $ZASCII() returns a result based on the first byte position. $ZASCII() starts numbering byte positions at
one (1), (the first byte of a string is at position one (1)).
• If the explicit or implicit position is before the beginning or after the end of the expression, $ZASCII() returns a value of
negative one (-1).
• $ZASCII() provides a means of examining bytes in a byte sequence. When used with $ZCHAR(), $ZASCII() also provides a
means to perform arithmetic operations on the byte values associated with a sequence of octets (8-bit bytes).
Examples of $ZASCII()
Example:
GTM>for i=0:1:4 write !,$zascii("主",i)
Functions
250
-1
228
184
187
-1
GTM>
This UTF-8 mode example displays the result of $ZASCII() specifying a byte position before, first, second and third positions,
and after the sequence of octets (8-bit bytes) represented by 主. In the above example, 228, 184, and 187 represents the numeric
byte value of the three-byte in the sequence of octets (8-bit bytes) represented by 主.
$ZATRansform
Returns the transformed representation of the first argument expr in a normalized form using the alternative transform
specified by the second argument intexpr; the transformed representation can be used as an operand to the follows (]) or sortsafter (]]) operator such that, if both operands are in the normalized form, the result is independent of alternative collation. The
format for the $ZATRANSFORM() function is:
$ZATRANSFORM(expr,intexpr[,{0|1|2|-2}][,{0|1}])
• The expression specifies the string to transform.
• The intexpr specifies the ID of the alternative transform to use.
• The optional third argument specifies:
• zero (0): the transform is to normalized form
• one (1): the reverse transform from the normalized to the native form
• two (2): the character which collates immediately after the first character of the first argument, or the empty string if no
character does.
• minus two (-2): character which collates immediately before the first character of the first argument, or the empty string if
no character does.
• The optional fourth argument specifes whether to use standard M collation of numbers before strings, the default or zero (0),
or to sort all values as strings (1).
Please see “$ZCOllate()” (page 258) for a similar alternative.
The 2 and -2 work in M mode for the 'M' collation (collation 0), or any user defined collation which supplies the necessary
plugin functionality. In UTF-8 mode, these argument values produce a ZATRANSCOL error. If the plugin for the specified
collation does not support this "next character" functionality, the function produces a COLLATIONUNDEF error in response
to an an attempt to invoke it. If an external collation library is used and encounters a gtm_ac_xutil failure, ZATRANSFORM
produces an ERR_ZATRANSCOL. If an external collation library is used and does not supply a gtm_ac_xutil function,
ZATRANSFORM produces an ERR_COLLATIONUNDEF when operations -2 or 2 are specified. To use these operations with
external collation libraries, the libraries must supply a function called 'gtm_ac_xutil'. For more information on the following
signature and characteristics of the gtm_ac_xutil function, refer to “Transform Utility Routine (gtm_ac_xutil)” (page 549).
Functions
251
Examples of $ZATRANSFORM()
Example:
GTM>write $zatransform("John Smythe",1)]$zatransform("Jane Smith",2)
0
GTM>
This example uses $ZATRANSFORM() and two (here unspecified) collation definitions to compare the ordering of two (literal)
expressions as GT.M would collate them if there was a way to collate them together. The result indicates that the first would
collate before the second.
$ZAUditlog
Sends its argument to an audit logger/listener process. This function requires setting the AZA_ENABLE audit logging facility in
the $gtm_dist/restrict.txt file. For information on setting up the AZA_ENABLE audit logging facility, refer to "Configuring the
Restriction Facility" section in the GT.M Administration and Operations Guide.The format for the $ZAUDITLOG() function
is:
ZAUDITLOG(expr)
• expr specifies the string to send for audit logging
• A return of TRUE (1) indicates successful logging, FALSE (0) indicates logging is not enabled; a trappable RESTRICTEDOP
error indicates logging is enabled but not working.
• $ZAUDITLOG() identifies its message with src=4, and like other GT.M logging facilities, records the location of GT.M
distribution, uid, euid, pid, tty, and the command / argument(s).
• If LGDE is specified as an option for the AZA_ENABLE facility, GDE logs all commands. GT.M ignores this option if
specified with other A*_ENABLE audit logging facilities. When it fails to log a command, GDE issues a GDELOGFAIL error.
The following table characterizes $ZAUDITLOG() and GDE audit logging behavior:
$ZAUDITLOG() / GDE logging Characteristics
AZA_ENABLE LGDE Logging success GDE audit logging $ZAUDITLOG() result
Yes Yes Yes Yes 1
Yes No Yes No 1
Yes Yes No GDELOGFAIL error RESTRICTEDOP error
Yes No No No RESTRICTEDOP error
No N/A N/A No 0
Examples of $ZAUDitlog()
Example:
GTM>write $zauditlog("Name Change for "_ip)
1
Functions
252
GTM>
This example uses $ZAUDITLOG() to log a literal label concatenated with a variable (identifier). The return indicates the
logging was successful.
$ZBIT Functions
A series of functions beginning with $ZBIT lets you manipulate a bit stream. Internally, GT.M stores a bit stream in the form
of a bit string. A bit string embeds a bit stream in such a way that the first byte specifies the number of trailing bits in the last
byte that are not part of the bit-stream. In this way, GT.M is able to store bit-streams of lengths other than multiples of 8 bits in
byte format. So for example, a first byte of value of zero (0) indicates that all of the bits in the last byte belong to the bit-stream,
while a one (1) indicates the last bit is excluded and a seven (7) indicates that only the first bit in the last byte belongs to the bitstream.
If you have to convert a character string into a bit string then add a leading byte to that character string so that all $ZBIT
functions can recognize it. The most common and straightforward way of doing this is to concatenate a $CHAR(n) on the front
of the character string, where the value of n is zero through seven (0-7) – most commonly zero (0). If you pass a bit string as an
argument to a routine that is expecting a character string, then that caller routine must strip off the first (and possibly the last)
byte so that it can recognize the character string.
This section contains the description of all $ZBIT function and an example of using $ZBIT functions to turn a character into
a bit stream and return a coded value. However, the most appropriate use of these functions may include the formation of
checksums, handling of bit-data (say pixels from a scan), or interfacing with a routine that requires bit-oriented arguments.
$ZBITAND()
Performs a logical AND function on two bit strings and returns a bit string equal in length to the shorter of the two arguments
(containing set bits in those positions where both of the input strings have set bits). Positions corresponding to positions where
either of the input strings have a cleared bit, also have cleared bits in the resulting string.
The format for the $ZBITAND() function is:
$ZBITAND(expr1,expr2)
• The first expression specifies one of the bit strings that is input to the AND operation.
• The second expression specifies the other bit string that is input to the AND operation.
Example of $ZBITAND()
GTM>
; The binary representation of A is 01000001
GTM>Set BITSTRINGB=$zbitset($zbitset($zbitstr(8,0),2,1),7,1)
; The binary representation of B is 01000010
GTM>set BITSTRINGAB=$zbitand(BITSTRINGA,BITSTRINGB)
GTM>for i=1:1:8 write $zbitget(BITSTRINGAB,I)
01000000
This examples uses $ZBITAND to perform a bitwise AND operation on A and B.
A= 01000001
B= 01000010
A bitwise AND B=0100000
Functions
253
$ZBITCOUNT()
Returns the number of ON bits in a bit string.
The format for the $ZBITCOUNT function is:
$ZBITCOUNT(expr)
• The expression specifies the bit string to examine.
Example of $ZBITCOUNT()
Example:
GTM>set BITSTRINGA=$ZBITSET($ZBITSET($ZBITSTR(8,0),2,1),8,1)
; The binary representation of A is 01000001
GTM>set BITSTRINGB=$zbitset($zbitset($zbitstr(8,0),2,1),7,1)
; The binary representation of B is 01000010
GTM>Set BITSTRINGC=$zbitor(BITSTRINGA,BITSTRINGB)
; A OR B=01000011
GTM>write $zbitcount(BITSTRINGA)
2
GTM>write $zbitcount(BITSTRINGB)
2
GTM>write $zbitcount(BITSTRINGC)
3
GTM>
This example displays the number of ON bits in BITSTRINGA, BITSTRINGB, and BITSTRINGC.
$ZBITFIND()
Performs the analog of $FIND() on a bit string. It returns an integer that identifies the position after the first position equal to a
truth-valued expression that occurs at, or after, the specified starting position.
The format for the $ZBITFIND function is:
$ZBITFIND(expr,tvexpr[,intexpr])
• The expression specifies the bit string to examine.
• The truth-valued expression specifies the bit value for which $ZBITFIND() searches (1 or 0).
• The optional integer argument specifies the starting position at which to begin the search. If this argument is missing,
$ZBITFIND() begins searching at the first position of the string. $ZBIT functions count the first bit as position one (1).
If the optional integer argument exceeds the length of the string, or if the function finds no further bits, $ZBITFIND() returns a
zero value.
Examples of $ZBITFIND()
Example:
GTM>Set BITSTRINGA=$ZBITSET($ZBITSET($ZBITSTR(8,0),2,1),8,1)
Functions
254
; The binary representation of A is 01000001
GTM>write $zbitfind(BITSTRINGA,1,3)
9
GTM>
This example searches for bit value 1 starting from the 3rd bit of BITSTRINGA.
$ZBITGET()
Returns the value of a specified position in the bit string.
The format for the $ZBITGET function is:
$ZBITGET(expr,intexpr)
• The expression specifies the bit string to examine.
• The integer argument specifies the position in the string for which the value is requested. If the integer argument is negative,
zero, or exceeds the length of the bit string, it is rejected with a run-time error. $ZBIT functions count the first bit as position
one (1).
Examples of $ZBITGET()
Example:

GTM>set BITSTRINGA=$zbitset($zbitset($zbitstr(8,0),2,1),8,1)
; The binary representation of A is 01000001
GTM>for i=1:1:8 write $zbitget(BITSTRINGA,I)
01000001
GTM>
This examples uses $ZBITGET() to display the binary representation of A.
$ZBITLEN()
Returns the length of a bit string, in bits.
The format for the $ZBITLEN function is:
$ZBITLEN(expr)
• The expression specifies the bit string to examine.
Examples of $ZBITLEN()
GTM>set BITSTR=$zbitstr(6,1)

GTM>write $zbitlen(BITSTR)
6
GTM>
This example displays the length of a bit string of 6 bits.
Functions
255
$ZBITNOT()
Returns a copy of the bit string with each input bit position inverted.
The format for the $ZBITNOT function is:
$ZBITNOT(expr)
• The expression specifies the bit string whose inverted bit pattern becomes the result of the function.
Examples of $ZBITNOT()
GTM>set BITSTRINGA=$zbitset($zbitset($zbitstr(8,0),2,1),8,1)
; The binary representation of A is 01000001
GTM>for i=1:1:8 write $zbitget($zbitnot(BITSTRINGA),I)
10111110
GTM>
This example displays inverted bits for all the bits in BITSTRINGA.
$ZBITOR()
Performs a bitwise logical OR on two bit strings, and returns a bit string equal in length to the longer of the two arguments
(containing set bits in those positions where either or both of the input strings have set bits). Positions that correspond to
positions where neither input string has a set bit have cleared bits in the resulting string.
The format for the $ZBITOR function is:
$ZBITOR(expr1,expr2)
• The first expression specifies one of the bit strings that is input to the OR operation.
• The second expression specifies the other bit string that is input to the OR operation.
Examples of $ZBITOR()
GTM>set BITSTRINGA=$zbitset($zbitset($zbitstr(8,0),2,1),8,1)
; The binary representation of A is 01000001
GTM>set BITSTRINGB=$zbitset($zbitset($zbitstr(8,0),2,1),7,1)
; The binary representation of B is 01000010
GTM>set BITSTRINGC=$zbitor(BITSTRINGA,BITSTRINGB)
; A OR B=01000011
GTM>write BITSTRINGC
C
GTM>
This example displays the result of BITSTRINGA bitwise ORed with BITSTRINGB.
$ZBITSET()
Returns an edited copy of the input bit string with a specified bit set to the value of the truth-valued expression.
Functions
256
The format for the $ZBITSET function is:
$ZBITSET(expr,intexpr,tvexpr)
• The expression specifies the input bit string.
• The integer expression specifies the position of the bit to manipulate. Arguments that are negative, zero, or exceed the length
of the bit string produce a run-time error. $ZBIT functions count the first bit as position one (1).
• The truth-valued expression specifies the value to which to set the specified bit (0 or 1).
Examples of $ZBITSET()
GTM>set X="A",Y=$extract($zbitset($char(0)_X,3,1),2) zwrite
X="A"
Y="a"
This example changes the case of the ASCII letter A to the corresponding lowercase version.
$ZBITSTR()
Returns a bit string of a specified length with all bit positions initially set to either zero or one.
The format for the $ZBITSTR function is:
$ZBITSTR(intexpr[,tvexpr])
• The integer expression specifies the length of the bit string to return; arguments that exceed the maximum length of 253,952
produce a run-time error.
• The optional truth-valued expression specifies the value to which all bit positions should initially be set (0 or 1). If this
argument is missing, the bits are set to zero.
Examples of $ZBITSTR()
GTM>set BITSTR=$zbitstr(6,1)
This example sets the value of expression BITSTR to 6 bit with all bits set to 1.
$ZBITXOR()
Performs a bitwise exclusive OR on two bit strings, and returns a bit string equal in length to the shorter of the two arguments
(containing set bits in those position where either but not both of the input strings have set bits). Positions that correspond to
positions where neither or both input string has a set bit have cleared bits in the resulting string.
The format for the $ZBITXOR function is:
$ZBITXOR(expr1,expr2)
• The first expression specifies one of the bit strings that is input to the XOR operation.
• The second expression specifies the other bit string that is input to the XOR operation.
Functions
257
Examples of $ZBITXOR()
GTM>set BITSTRINGA=$zbitset($zbitset($zbitstr(8,0),2,1),8,1) ; The binary representation of A is 01000001
GTM>set BITSTRINGB=$zbitset($zbitset($zbitstr(8,0),2,1),7,1); The binary representation of B is 01000010
GTM>set BITSTRINGC=$zbitor(BITSTRINGA,BITSTRINGB) ; A XOR B=00000011
GTM>for I=1:1:8 write $zbitget(BITSTRINGC,I)
00000011
GTM>
This example displays the result of the bitwise XOR of A and B.
Examples of $ZBIT Functions
Example:
ZCRC(X)
 new R,I,J,B,X1,K
 set R=$zbitstr(8,0)
 for I=1:1:$length(X) Set R=$zbitxor(R,$$bitin($A(X,I)))
 quit $$bitout(R)

bitin(X) ;CONVERT A BYTE TO A BIT STRING
 set X1=$zbitstr(8,0)
 for J=1:1:8 set B=X#2,X=X\2 if B set X1=$zbitset(X1,J,1)
 quit X1

bitout(X) ; CONVERT A BITSTRING TO A NUMBER
 set X1=0
 for K=1:1:8 I $zbitget(X,K) set X1=X1+(2**(K-1))
 quit X1
This uses several $ZBIT functions to turn a character into a bit stream and return a coded value.
While this example illustrates the use of several of the $ZBIT functions, the following example produces identical results if you
need to code the function illustrated above for production.
ZCRC(X)
 new R,I,J,B,X1,K
 set R=$zbitstr(8,0)
 for I=1:1:$length(X) Set R=$zbitxor(R,$char(0)_$extract(X,I))
 quit $ascii(R,2)
This example illustrates the use of $Char() to specify the number of invalid bits that exist at the end of the character string. In
this case there are zero invalid bits.
$ZCHar()
Returns a string composed of bytes represented by the integer octet values specified in its argument(s).
The format for the $ZCHAR() function is:
$ZCH[AR](intexpr[,...])
• The integer expression(s) specify the numeric byte value of the byte(s) $ZCHAR() returns.
Functions
258
• GT.M limits the number of arguments to a maximum of 254. $ZCHAR() provides a means of producing byte sequences. In the
UTF-8 mode, $ZCHAR() returns a malformed characters for numeric byte values 128 to 255. In the M mode, $ZCHAR() can
create valid UTF-8 characters that includes bytes in the range 128-255.
Note
The output of $ZCHAR() for values of integer expression(s) from 0 through 127 does not vary with choice of
the character encoding scheme. This is because 7-bit ASCII is a proper subset of UTF-8 character encoding
scheme. The representation of characters returned by $ZCHAR() for values 128 through 255 differ for each
character encoding scheme.
• When used with $ZASCII(), $ZCHAR() can also perform arithmetic operations on the byte values of the bytes associated with
a sequence of octets (8-bit bytes).
Example of $ZCHAR()
Example:
GTM>write $zchar(228,184,187,7)
主
GTM>
This example WRITEs the byte sequence represented by 主 and signals the terminal bell.
$ZCOllate()
Returns the transformed representation of the first argument glvn in a normalized form using the alternative transform
specified by the second argument intexpr; the return can be used as an operand to the follows (]) or sorts-after (]]) operator
such that, if both operands are in the normalized form, the result is independent of alternative collation.
The format for the $ZCOLLATE() function is:
$ZCO[llate](glvn,intexpr[,{0|1}])
• The subscripted or unsubscripted global or local variable name specifies the key to transform.
• The integer expression specifies the ID of the alternative transform to use.
• The optional third argument specifies whether the transform is to normalized form, by default or if zero (0), or, if one (1), the
reverse transform from the normalized to the native form.
Note that because the forward transform is to the GDS global storage format, the reverse transform always shows a global
form. This is not material when the result is used for most comparisons, but for some uses the applcation might need to remove
the leading up-arrow (^).
Please see the section on $ZATRANSFORM() for a similar alternative.
Example of $ZCOllate()
Example:
GTM>write $zwrite($zcollate("A(""foo"")",0))
"A"_$C(0,255)_"foo"_$C(0,0)
Functions
259
GTM>write $zcollate($zcollate("A(""foo"")",0),0,1)
^A("foo")
GTM>
The first WRITE in this example shows the readable form or the value produced by the $ZCOLLATE() revealing the details of
how GT.M internally represents this key using default (M) collation. The second WRITE shows how the combination of the
transform and reverse transform restores the value to the original representation.
$ZCOnvert()
Returns its first argument as a string converted to a different encoding. The two argument form changes the encoding for case
within a character set. The three argument form changes the encoding scheme.
The format for the $ZCONVERT() function is:
$ZCO[NVERT](expr1, expr2,[expr3])
• The first expression is the string to convert. If the expression contains a code-point value that is not in the character set,
$ZCONVERT() generates a run-time error.
• In the two argument form, the second expression specifies a code that determines the form of the result. In the threeargument form, the second expression specifies a code that controls the character set interpretation of the first argument.
If the expression does not evaluate to one of the defined codes corresponding to a valid code for the number of available
arguments, $ZCONVERT() generates a run-time error.
• The optional third expression specifies the a code that determines the character set of the result. If the expression does
not evaluate to one of the defined codes $ZCONVERT() generates a run-time argument. The three-argument form is not
supported in M mode.
• The valid (case insensitive) character codes for expr2 in the two-argument form are:
• U converts the string to UPPER-CASE. "UPPER-CASE" refers to words where all the characters are converted to their
"capital letter" equivalents. $ZCONVERT() retains characters already in UPPER-CASE "capital letter" form unchanged.
• L converts the string to lower-case. "lower-case" refers to words where all the letters are converted to their "small letter"
equivalents. $ZCONVERT() retains characters already in lower-case or having no lower-case equivalent unchanged.
• T converts the string to title case. "Title case" refers to a string with the first character of each word in upper-case and the
remaining characters in the lower-case. $ZCONVERT() retains characters already conforming to "Title case" unchanged.
• The valid (case insensitive) codes for character set encoding for expr2 and expr3 in the three-argument form are:
• "UTF-8"-- a multi-byte variable length Unicode® encoding form.
• "UTF-16LE"-- a multi-byte 16-bit Unicode® encoding form in little-endian.
• "UTF-16BE"-- a multi-byte 16-bit Unicode® encoding form in big-endian.
• "UTF-16"-- a multi-byte 16-bit Unicode® encoding form which uses the same endian level as that of the current system.
Note
When UTF-8 mode is enabled, GT.M uses the ICU Library to perform case conversion. As mentioned in
the Theory of Operation section, the case conversion of the strings occurs according to UTF-8 code-point
Functions
260
values. This may not be the linguistically or culturally correct case conversion, for example, of the names in
the telephone directories. Therefore, application developers must ensure that the actual case conversion is
linguistically and culturally correct for their specific needs. The two-argument form of the $ZCONVERT()
function in M mode does not use the ICU Library to perform operation related to the case conversion of the
strings.
Examples of $ZCONVERT()
Example:
GTM>write $zconvert("Happy New Year","U")
HAPPY NEW YEAR
Example:
GTM>Write $zconvert("HAPPY NEW YEAR","T")
Happy New Year
Example:
GTM>Set T8="主要雨在西班牙停留在平原"
GTM>Write $Length(T8)
12
GTM>Set T16=$zconvert(T8,"UTF-8","UTF-16LE")
GTM>Write $length(T16)
%GTM-E-BADCHAR, $ZCHAR(129,137,232,150) is not a valid character in the UTF-8 encoding form
GTM>Set T16=$ZCOnvert(T16,"UTF-16LE","UTF-8")
GTM>Write $length(T16)
9
In the above example, $LENGTH() function triggers an error because it takes only UTF-8 encoding strings as the argument.
$ZDATA()
Extends $DATA() to reflect the current alias state of the lvn or name argument to identify alias and alias container variables.
It treats variables joined through pass-by-reference as well as TP RESTART variables within a transaction as alias variables.
However, it does not distinguish nodes having alias containers among their descendants.
In addition to the four standard M results from $DATA(), $ZDATA() returns:
• 100 for an uninitialized alias or alias container
• 101 for an alias or alias container with no descendants
• 111 for an alias or alias container with descendants
Existing $DATA() tests for data and descendants report on alias and alias container variables, as well as other variables in the
standard fashion. When an application uses alias and alias container variables $ZDATA() supplies additional information when
needed.
Examples of $ZDATA()
Example:
Functions
261
GTM>set a=1,*b(1)=a,*c=d
GTM>write $data(a)," ",$zdata(a)
1 101
GTM>write $data(b)," ",$zdata(b)
10 10
GTM>write $data(c)," ",$zdata(c)
0 100
GTM>write $data(d)," ",$zdata(d)
0 100
GTM>write $data(b(1))," ",$zdata(b(1))
1 101
GTM>set b(1,2)=2
GTM>write $data(b(1))," ",$zdata(b(1))
11 111
GTM>write $data(b(1,2))," ",$zdata(b(1,2))
1 1
GTM>
$ZDate()
Returns a date and/or time formatted as text based on an argument formatted in the manner of $HOROLOG. For information on
the format of $HOROLOG, refer to Chapter 8: “Intrinsic Special Variables” (page 290).
The format for the $ZDATE function is:
$ZD[ATE](expr1[,expr2[,expr3[,expr4]]]])
• The first expression specifies in $HOROLOG format the date and/or time that $ZDATE() returns in text format. If the output
requires only the date or the time, the other piece of the argument that is delimited by a comma (,) may be null.
• The optional second expression specifies a string providing $ZDATE() with a "picture" of the desired output format. If this
argument is missing or null, $ZDATE() uses the default format string "MM/DD/YY". If the optional second expression exceeds
64 characters, $ZDATE() generates a run-time error.
• The optional third expression specifies a list of 12 month codes, separated by commas (,), that $ZDATE() uses in formatting
text months called for by the "MON" picture, (that is, $ZDATE() outputs $PIECE(expr3,",",month-number) when "MON"
appears in the second expression). If this argument is missing or null, $ZDATE() uses three-character English abbreviations
for months.
• The optional fourth expression specifies a list of seven day codes, separated by commas (,), which $ZDATE() uses in
formatting text days of the week called for by the "DAY" picture, $ZDATE() outputs $PIECE (expr4,",",day-of-week-number)
when "DAY" appears in the second expression; if this argument is missing or null, $ZDATE() uses three-character English
abbreviations for days of the week.
• $ZDATE() returns 31-Dec-1840 as a date representation of day 0.
$ZDATE() provides an easy and flexible tool for putting M internal date/time ($HOROLOG) formats into more user-friendly
formats.
Warning
$ZDATE() generates an error for input date values greater than 31-Dec-999999 (364570088) or less than 01-
JAN-1840 (-365) and for time values greater than a second before midnight (86399) or less than 0 (zero).
Functions
262
The Intrinsic Special Variable $ZDATEFORM determines the output format for years. The default value is zero (0), in which
case $ZDATE() with one argument (no format specification) uses a "YY" (two digit) format for all years. If $ZDATEFORM is
one (1), a "YYYY" (four digit) format is used for years later than 1999. For all other values of $ZDATEFORM, "YYYY" (four digit)
format is used for all years. $ZDATEFORM does not affect $ZDATE() when the format argument is specified.
The following table summarizes the usage of $ZDATE() when only first argument is specified.
Value of $ZDATEFORM $ZDATE() Output Format
0 2 digits
1 4 digits for years 2000 and after
2 digits otherwise (for years ranging between 1840, 1999)
other 4 digits
$ZDATE Format Specification Elements
This section lists the $ZDATE format specification elements. $ZDATE() format specifications must appear in upper case. When
any alphabetic characters in format specifications are in lower case, $ZDATE() generates a run-time error.
YY: Outputs the rightmost two digits of the year.
YEAR or YYYY: Outputs the year as a four-digit number.
YYYYYY: Outputs the year as a six-digit number.
MM: Outputs the month as a two-digit zero-filled number between 01 and 12.
MON: Outputs the month as a three-letter abbreviation. (You can modify the output further using expr3).
DD: Outputs the day of the month as a two-digit zero-filled number between 01 and 31.
DAY: Outputs the day of the week as a three-letter abbreviation. (You can modify the output further using expr4).
24: Outputs the hour of the day as a zero-filled number between 00 and 23.
12: Outputs the hour of the day as a zero-filled number between 01 and 12.
60: Outputs the minute of the hour as a zero-filled number between 00 and 59.
SS: Outputs the second of the minute as a zero-filled number between 00 and 59.
AM: Outputs the letters AM and PM depending on the time.
+: Inserts a plus sign (+) in the output string
-: Inserts a minus sign (-) in the output string.
.: Inserts a period (.) in the output string.
,: Inserts a comma (,)in the output string.
/: Inserts a slash (/) in the output string.
Functions
263
:: Inserts a colon (:) in the output string.
;: Inserts a semi-colon (;) in the output string.
*: Inserts an asterisk (*) in the output string.
Note
A blank space inserts a blank space in the output string.
Examples of $ZDATE()
Example:
GTM>write $horolog,!,$zdate($H)
62109,60946
01/18/11
GTM>
This displays $HOROLOG and then uses $ZDATE() to display today's date. The output shown would appear if today were the
eighteenth day of January, 2011.
Example:
GTM>write $zdate($H,"DD-MON-YEAR")
18-JAN-2011
GTM>
This uses the second argument to specify a text format different from the default.
Example:
GTM>set m="Januar,Februar,Marz,April,Mai,Juni,Juli,August,"
GTM>set m=m_"September,October,November,Dezember"
GTM>write $zdate($horolog,"DD-MON-YEAR",m)
18-Januar-2011
GTM>
This is similar to the prior example, however it uses the third argument to specify the months in German.
Example:
GTM>set d="Dimanche,Lundi,Mardi,Mercredi,Jeudi,Vendredi,Samedi"
GTM>write $zdate($H,"DAY, DD/MM/YY","",d)
Mardi, 18/01/2011
GTM>
This example displays the eighteenth of January, however it uses the fourth argument to specify the days of the week in French.
Example:
GTM>write !,$zdate($H,"12:60:SS AM")
10:35:51 PM
GTM>
This example shows hours, minutes, and seconds in a 12 hour clock with an AM/PM indicator.
Functions
264
Example:
GTM>write !,$zdate(",36524","24-60")
10-08
GTM>
This example shows hours and minutes on a 24 hour clock. Notice that the first argument must provide the time in the second
comma delimiter piece to match $HOROLOG format.
Example:
GTM>write $zdateform
0
GTM>write $zdate($H)
01/18/11
GTM>set $zdateform=1
GTM>write $zdate($horolog)
01/18/2011
GTM>write $zdate($horolog,"MM/DD/YY")
01/18/11
This example converts the output format for years from the default ("YY") format to the four digit format ("YYYY") using the
Intrinsic Special Variable $ZDATEFORM.
Example:
GTM>write $zdate(123456789,"DAY MON DD, YYYYYY")
FRI MAR 17, 339854
GTM>
This example displays year as a six-digit number.
$ZExtract()
Returns a byte sequence from a given sequence of octets (8-bit bytes).
The format for the $ZEXTRACT function is:
$ZE[XTRACT](expr[,intexpr1[,intexpr2]])
• The expression specifies a sequence of octets (8-bit bytes) from which $ZEXTRACT() derives a byte sequence.
• The first optional integer expression (second argument) specifies the starting byte position in the byte string. If the starting
position is beyond the end of the expression, $ZEXTRACT() returns an empty string. If the starting position is zero (0) or
negative, $ZEXTRACT() starts at the first byte position in the expression; if this argument is omitted, $ZEXTRACT() returns
the first byte. $ZEXTRACT() numbers byte positions starting at one (1) (the first byte of a sequence of octets (8-bit bytes) is at
position one (1)).
• The second optional integer expression (third argument) specifies the ending byte position for the result. If the ending
position is beyond the end of the expression, $ZEXTRACT() stops with the last byte of the expression. If the ending position
precedes the starting position, $ZEXTRACT() returns null. If this argument is omitted, $ZEXTRACT() returns one byte.
• $ZEXTRACT() provides a tool for manipulating strings based on byte positions.
• As $ZEXTRACT() operates on bytes, it can produce a string that is not well-formed according to the UTF-8 character set.
Functions
265
Examples of $ZEXTRACT()
Example:
GTM>Set A="主要雨在西班牙停留在平原"

GTM>For i=0:1:$zlength(A)
GTM>write !,$zascii($zextract(A,i)),"|"
GTM>
This example displays the numeric byte sequence of the sequence of octets ("主要雨在西班牙停留在平原").
$ZFind()
Returns an integer byte position that locates the occurrence of a byte sequence within a sequence of octets(8-bit bytes).
The format of the $ZFIND function is:
$ZF[IND](expr1,expr2[,intexpr])
• The first expression specifies the sequence of octets (8-bit bytes) in which $ZFIND() searches for the byte sequence.
• The second expression specifies the byte sequence for which $ZFIND() searches.
• The optional integer expression identifies the starting byte position for the $ZFIND() search. If this argument is missing, zero
(0), or negative, $ZFIND() begins to search from the first position of the sequence of octets (8-bite bytes).
• If $ZFIND() locates the byte sequence, it returns the position after its last byte. If the end of the byte sequence coincides
with the end of the the sequence of octets (expr1), it returns an integer equal to the byte length of the expr1 plus one
($L(expr1)+1).
• If $ZFIND() does not locate the byte sequence, it returns zero (0).
• $ZFIND() provides a tool to locate byte sequences. The ( [ ) operator and the two-argument $ZLENGTH() are other tools that
provide related functionality.
Examples
Example:
GTM>write $zfind("主要雨",$zchar(187))
4
GTM>
This example uses $ZFIND() to WRITE the position of the first occurrence of the numeric byte code 150. The return of 3 gives
the position after the "found" byte.
Example:
GTM>write $zfind("新年好",$zchar(229),5)
8
GTM>
This example uses $ZFIND() to WRITE the position of the next occurrence of the byte code 229 starting in byte position five.
Functions
266
Example:
GTM>set t=1 for set t=$zfind("新年好",$zchar(230,150,176),t) quit:'t write !,t
4
GTM>
This example uses a loop with $ZFIND() to locate all the occurrences of the byte sequence $ZCHAR(230,150,176) in
the sequence of octets ("新年好"). The $ZFIND() returns 4 giving the position after the occurrence of byte sequence
$ZCHAR(230,150,176).
$ZGetjpi()
Returns job or process information of the specified process. The format for the $ZGETJPI function is:
$ZGETJPI(expr1,expr2)
• expr1 identifies the PID of the target job. If expr1 is an empty string (""), $ZGETJPI() returns information about the current
process.
• expr2 specifies the item keyword identifying the type of information returned; keywords may be upper, lower, or mixed-case.
The keywords are as follows:
ZGETJPI()
Keywords Data returned
ISPROCALIVE Determines whether the specified process is alive.
CPUTIM Total process and child CPU time used in hundredths of a second.
CSTIME System time of child processes
CUTIME User time of child processes
STIME Process system time
UTIME Process user time
• Note that the $ZGETJPI() retrieves process time measurements (CPUTIM, CSTIME, CUTIME, STIME, and UTIME) only of
the current process ($JOB). The "child" process time includes ZSYSTEM and PIPE device sub-processes (only after the PIPE
CLOSEs), but excludes processes created by the JOB command.
• $ZGETJPI() provides a tool for examining the characteristics of a UNIX process. Accessing information about processes
belonging to other users requires certain UNIX privileges. Consult your system manager if you require additional privileges.
Examples
Example:
GTM>write $zgetjpi(1975,"isprocalive")
1
GTM>
This uses $ZGETJPI() to determine whether process 1975 is alive.
Functions
267
Example:
GTM>set t=$zgetjpi("","cputim")
GTM>do ^bench write $zgetjpi("","cputim")-t
1738
GTM>
This uses $ZGETJPI() to measure the actual CPU time, measured in hundredths of a second, consumed by running the ^bench
routine.
$ZJOBEXAM()
Places ZSHOW <code> output into a file and returns the absolute file name. The format for the $ZJOBEXAM function is:
$ZJOBEXAM([expr1][,expr2])
• The optional first expression is the output specification. It can be a file directory or a file name. $ZJOBEXAM() pre-processes
the first expression to create a file specification as the target for the ZSHOW command output. The preprocessing is
equivalent to $ZPARSE(), as illustrated by the following M code:
GTM>set cntr=1,deffn="GTM_JOBEXAM.ZSHOW_DMP_"_$JOB_"_"_cntr
GTM>w $zparse(deffn)
/path/to/GTM_JOBEXAM.ZSHOW_DMP_49878_1
GTM>w $zjobexam()
/path/to/GTM_JOBEXAM.ZSHOW_DMP_49878_1
GTM>
• The optional second expression evaluates to a string containing a list of one or more ZSHOW information codes that
determine the type of information. If the second expression is missing or empty, GT.M operates as it was a "*" and produces
all context. Note that using an explicit list may be useful in limiting the exposure of sensitive information. For more
information, refer to to “ZSHOW Information Codes” (page 192).
The return value serves as a way to save, to notify others of the exact location of the output or to open the file for further
processing. GT.M logs the JOBEXAMDONE message to the operator log for each $ZJOBEXAM() which includes the full file
specification.
The $ZJOBEXAM()does not trigger error processing except when there is a problem storing its return value, so no error is
reported to the process until after any dump is complete. In the event of any error encountered during the $ZJOBEXAM(),
GT.M sends an appropriate message to operator log facility and returns control to the caller. Note that this special error
handling applies only to the $ZJOBEXAM(), and is not a property of the $ZINTERRUPT interrupt handler, which uses
$ZJOBEXAM() by default.
$ZJOBEXAM() dump files contain the context of a process at the time the function executes. Placement and management of
these files should consider their potential size and security implications.
Examples of $ZJOBEXAM()
Example:
GTM>set x=$zjobexam()
GTM>write x
/tmp/GTM_JOBEXAM.ZSHOW_DMP_383974_1
GTM>set x=$zjobexam("jobexam.out")
Functions
268
GTM>write x
/tmp/jobexam.out
GTM>set x=$zjobexam("jobexam_ISV.out","I")
GTM>write x
/tmp/jobexam_ISV.out
GTM>
In the first two examples, the output file contains zshow "*" information. The 3rd example saves zshow "I" (ISVs only)
information in the output file.
$ZJustify()
Returns a formatted and fixed length byte sequence.
The format for the $ZJUSTIFY() function is:
$ZJ[USTIFY](expr,intexpr1[,intexpr2])
• The expression specifies the sequence of octets formatted by $ZJUSTIFY().
• The first integer expression (second argument) specifies the minimum size of the resulting byte sequence.
• If the first integer expression is larger than the length of the expression, $ZJUSTIFY() right justifies the expression to a byte
sequence of the specified length by adding leading spaces. Otherwise, $ZJUSTIFY() returns the expression unmodified unless
specified by the second integer argument.
• The behavior of the optional second expression (third argument) for $ZJUSTIFY() is the same at $JUSTIFY(). For more
information, refer to “$Justify()” (page 223).
• When the second argument is specified and the first argument evaluates to a fraction between -1 and 1, $ZJUSTIFY() returns
a number with a leading zero (0) before the decimal point (.).
• $ZJUSTIFY() fills a sequence of octets to create a fixed length byte sequence. However, if the length of the specified
expression exceeds the specified byte size, $ZJUSTIFY() does not truncate the result (although it may still round based on the
third argument). When required, $ZEXTRACT() performs truncation.
• $ZJUSTIFY() optionally rounds the portion of the result after the decimal point. In the absence of the third argument,
$ZJUSTIFY() does not restrict the evaluation of the expression. In the presence of the third (rounding) argument, $JUSTIFY()
evaluates the expression as a numeric value. The rounding algorithm can be understood as follows:
• If necessary, the rounding algorithm extends the expression to the right with 0s (zeros) to have at least one more digit than
specified by the rounding argument.
• Then, it adds 5 (five) to the digit position after the digit specified by the rounding argument.
• Finally, it truncates the result to the specified number of digits. The algorithm rounds up when excess digits specify a half
or more of the last retained digit and rounds down when they specify less than a half.
Examples of $ZJUSTIFY()
Example:
GTM>write "123456789012345",! write $zjustify("新年好",15),!,$zjustify("新年好",5)
123456789012345
Functions
269
 新年好
新年好
GTM>
This example uses $ZJUSTIFY() to display the sequence of octets represented by "新年好" in fields of 15 space octets and 5
space octets. Because the byte length of "新年好" is 9, it exceeds 5 spaces, the result overflows the specification.
$ZLength()
Returns the length of a sequence of octets measured in bytes, or in "pieces" separated by a delimiter specified by one of its
arguments.
The format for the $ZLENGTH() function is:
$ZL[ENGTH](expr1[,expr2])
• The first expression specifies the sequence of octets that $ZLENGTH() "measures".
• The optional second expression specifies the delimiter that defines the measure; if this argument is missing, $ZLENGTH()
returns the number of bytes in the sequence of octets.
• If the second argument is present and not null, $ZLENGTH() returns one more than the count of the number of occurrences
of the second byte sequence in the first byte sequence; if the second argument is null , the M standard for the analogous
$LENGTH() dictates that $ZLENGTH() returns a zero (0).
• $ZLENGTH() provides a tool for determining the lengths of a sequence of octets in two ways--bytes and pieces. The two
argument $ZLENGTH() returns the number of existing pieces, while the one argument returns the number of bytes.
Examples of $ZLength()
Example:
GTM>write $zlength("主要雨在西班牙停留在平原")
36
GTM>
This uses $ZLENGTH() to WRITE the length in bytes of the sequence of octets "主要雨在西班牙停留在平原".
Example:
GTM>set x="主"_$zchar(63)_"要"_$zchar(63)_"雨"
GTM>write $zlength(x,$zchar(63))
3
GTM>
This uses $ZLENGTH() to WRITE the number of pieces in a sequence of octets, as delimited by the byte code $ZCHAR(63).
Example:
GTM>set x=$zchar(63)_"主"_$zchar(63)_"要"_$zchar(63)_"雨"_$zchar(63)"
GTM>write $zlength(x,$zchar(63))
5
GTM>
This also uses $ZLENGTH() to WRITE the number of pieces in a sequence of octets, as delimited by byte code $ZCHAR(63).
Notice that GT.M counts both the empty beginning and ending pieces in the string because they are both delimited.
Functions
270
$ZMessage()
Returns a message string associated with a specified status code .
The format for the $ZMESSAGE function is:
$ZM[ESSAGE](intexpr)
• The integer expression specifies the status code for which $ZMESSAGE() returns error message text .
$ZMESSAGE() provides a tool for examining the message and/or mnemonic associated with a particular message code as
reported in $ZSTATUS.
The $ZSTATUS Intrinsic Special Variable holds the message code and the message of the last non-Direct Mode GT.M error. For
more information on $ZSTATUS, refer "Intrinsic Special Variables".
Examples of $ZMESSAGE()
Example:
GTM>write $zmessage(150373210)
%GTM-E-DIVZERO, Attempt to divide by zero
GTM>
This uses $ZMESSAGE() to display the message string corresponding to code 150373210.
$ZPARSE()
Expands a file name to a full pathname and then returns the full pathname or one of its fields (directory, name, or extension).
The format for the $ZPARSE function is:
$ZPARSE(expr1[,expr2[,expr3[,expr4[,expr5]]]])
• The first expression specifies the file name; if the file name is not valid, $ZPARSE() returns a null string; if the file name
contains a wildcard (* and/or ?), $ZPARSE() returns a file name containing the wildcard(s).
• The optional second expression specifies the field of the pathname that $ZPARSE() returns; if this argument is missing or
null, $ZPARSE() returns a full pathname constructed using default values in place of any fields missing for directory, file and
extension.
• The optional third and fourth expressions specify default values to use during file name expansion for missing fields
(directory, name, or extension), if any, in the original file name. For any field missing in the original file name specified
in expr1, $ZPARSE() will attempt to substitute the corresponding field from expr3; if that field is not present in expr3,
$ZPARSE() will attempt to use the corresponding field from expr4.
• If the file extension is missing from all three of expr1, expr3, and expr4, $ZPARSE() will return a null string for the
corresponding field. If the file or directory is missing from all three of expr1, expr3, and expr4, $ZPARSE() will substitute the
information from your current working directory.
• The optional fifth expression specifies the mode or type of parse that $ZPARSE() performs.
$ZPARSE() provides a tool for verifying that a file name is syntactically correct, for examining specific fields of a file name,
and for filling in missing pieces in a partial specification based on a hierarchy of defaults. For information about determining
whether a file exists, see “$ZSEARCH()” (page 281).
Functions
271
$ZPARSE() arguments, after the first, are optional. If you use no other arguments, a single argument is sufficient. However, if
you use selected arguments $ZPARSE() requires that null strings ("") be filled in for the unspecified arguments.
The acceptable keywords for the second argument are:
"DIRECTORY": Directory name
"NAME": File name (excluding file extension)
"TYPE": File type extension
The keywords may be entered in either upper or lower case. Variables that evaluate to these strings and indirection are
acceptable for argument two. When the keywords themselves appear as string literals, they must be enclosed in quotation
marks (" ").
The following guidelines must be followed in constructing arguments one, three and four:
• Directory specifications must end in a slash; anything after the final slash in the directory specification is assumed to be part
of the name specification.
• A file name with an extension must include at least one character to the left of the period (.). Thus, "/user/.login" refers to the
file named ".login", while "/usr/taxes.c" refers to a file named "taxes" with the extension "c". If a file name includes more than
one period, the extension includes all letters to the right of the rightmost period.
The keywords for the fifth argument $ZPARSE() are:
NULL (""): Returns a full file-specification or device
"SYNTAX_ONLY": Disables checking for the existence of the directory or device.
Examples of $ZPARSE()
Example:
GTM>write $zparse("test","","/usr/work/","dust.lis")
/usr/work/test.lis
GTM>
This uses $ZPARSE() to demonstrate defaulting using the third and fourth arguments. The result gets the directory field from
the third expression, the name from the first expression, and the type from the fourth expression.
Example:
GTM>r!,"file :",f w ?20,$zparse(f,"directory")
file: test.list /usr/work/
GTM>
This uses $ZPARSE() to display the directory for the file name entered as input at the prompt file: , in this case, the current
working directory.
Example:
$ cd /usr/work/me
$ $gtm
GTM>write $zparse("test","","x.list","y.c")/usr/work/me/test.lis
Functions
272
GTM>write $zparse("test","","/usr/work/","/dev/y.c")/usr/work/test.c
GTM>write $zparse("test","","/usr/work","/dev/y.c")/usr/test.c
GTM>
This example illustratest the use of the third and fourth arguments to $ZPARSE(). In the first statement, the first argument has
no directory or extension field, so $ZPARSE() substitutes the extension field from the third argument. Since neither the third
nor fourth argument specifies a directory, and because the fourth argument does not contain any fields that are not present in
the third argument, the fourth argument is not used.
In the second statement, the first argument to $ZPARSE() is again missing both the directory and extension. In this instance,
$ZPARSE() uses the directory specified in the third argument and, becuase neither the first nor third argument specifies a file
extension, $ZPARSE() uses the file extension from the fourth argument.
In the third statement, because "/usr/work" does not end with a backward slash (/), $ZPARSE() interprets the substring "work"
as a file name. Then, $ZPARSE() substitutes "/usr/" for the directory missing in the first argument and substitutes ".c" from the
fourth argument for the extension missing from both the first and third arguments.
Example:
$ cd /usr/work/me
$ /usr/lib/fis-gtm/V5.4-002B_x86/gtm
GTM>For i="DIRECTORY","NAME","TYPE","" Write $ZPARSE("test.m",i),!
/usr/work/me/
test
.m
/usr/work/me/test.m
GTM>
This example illustrates the output produced for each of the possible values for the second argument.
$ZPIece()
Return a sequence of bytes delimited by a specified byte sequence made up of one or more bytes.
The format for the $ZPIECE function is:
$ZPI[ECE](expr1,expr2[,intexpr1[,intexpr2]])
• The first expression specifies the sequence of octets from which $ZPIECE() takes its result.
• The second expression specifies the delimiting byte sequence that determines the piece "boundaries"; if this argument is a
null string, $ZPIECE() returns a null string.
• If the second expression does not appear anywhere in the first expression, $ZPIECE() returns the entire first expression
(unless forced to return null by the second integer expression).
• The optional first integer expression (third argument) specifies the beginning piece to return; if this argument is missing,
$ZPIECE() returns the first piece.
• The optional second integer expression (fourth argument) specifies the last piece to return. If this argument is missing,
$ZPIECE() returns only one piece unless the first integer expression is zero (0) or negative, in which case it returns a null
string. If this argument is less than the first integer expression, $ZPIECE() returns null.
• If the second integer expression exceeds the actual number of pieces in the first expression, $ZPIECE() returns all of the
expression after the delimiter selected by the first integer expression.
Functions
273
• The $ZPIECE() result never includes the "outside" delimiters; however, when the second integer argument specifies multiple
pieces, the result contains the "inside" occurrences of the delimiter.
• $ZPIECE() provides a tool for efficiently using values that contain multiple elements or fields, each of which may be variable
in length.
• Applications typically use a single byte for a $ZPIECE() delimiter (second argument) to minimize storage overhead, and
increase efficiency at run-time. The delimiter must be chosen so the data values never contain the delimiter. Failure to
enforce this convention with edit checks may result in unanticipated changes in the position of pieces within the data value.
The caret symbol (^), backward slash (\), and asterisk (*) characters are examples of popular visible delimiters. Multiple
byte delimiters may reduce the likelihood of conflict with field contents. However, they decrease storage efficiency, and are
processed with less efficiency than single byte delimiters. Some applications use control characters, which reduce the chances
of the delimiter appearing in the data but sacrifice the readability provided by visible delimiters.
• A SET command argument can have something that has the format of a $ZPIECE() on the left-hand side of its equal sign (=).
This construct permits easy maintenance of individual pieces within a sequence of octets. It also can be used to generate a
byte sequence of delimiters. For more information on SET $ZPIECE(), refer to SET in the "Commands" chapter.
Examples of $ZPIECE()
Example:
GTM>for i=0:1:3 write !,$zpiece("主"_$zchar(64)_"要",$zchar(64),i),"|"
|
主|
要|
|
GTM>
This loop displays the result of $ZPIECE(), specifying $ZCHAR(64) as a delimiter, a piece position "before," first and second, and
"after" the sequence of octets.
Example:
GTM>for i=-1:1:3 write !,$zpiece("主"_$zchar(64)_"要",$zchar(64),i,i+1),"|"
|
主|
主@要|
要|
|
GTM>
This example is similar to the previous example except that it displays two pieces on each iteration. Notice the delimiter () in
the middle of the output for the third iteration, which displays both pieces.
Example:
For p=1:1:$ZLength(x,"/") Write ?p-1*10,$ZPIece(x,"/",p)
This loop uses $ZLENGTH() and $ZPIECE() to display all the pieces of x in columnar format.
Example:
GTM>Set $piece(x,$zchar(64),25)="" write x
Functions
274
@@@@@@@@@@@@@@@@@@@@@@@@
This SETs the 25th piece of the variable x to null, with delimiter $ZCHAR(64). This produces a byte sequence of 24 at-signs (@)
preceding the null.
$ZPEEK()
Provides a way to examine memory in the current process address space. Use of this function requires information  about
GT.M internals, which may change from release to release. Contact FIS support for information on techniques for using
$ZPEEK() in largely release independent ways.
The $ZPEEK() function returns the contents of the memory requested as a string depending on the requested (or defaulted)
formatting.
The format of the $ZPEEK() function is:
$ZPEEK("mnemonic[:argument]",offset,length[,format])
• mnemonic specifies the memory area $ZPEEK() is to access. Some mnemonics have arguments separated from the
mnemonic by a colon (":"). The mnemonics are case independent. Possible mnemonics, their possible abbreviations and their
arguments are:
• CSA[REG] - returns a value from the sgmnt_addrs (process private) control block. Takes a case independent region name
as an argument.
• FH[REG] - returns a value from the sgmnt_data (shared file header) control block. Takes a case independent region name
as an argument..
• GDR[REG] - returns a value from the gd_region (process private) control block. Takes a case independent region name as
an argument.
• GLF[REPL] - returns a value from the jnlpool.gtmsrc_lcl_array[n] control block. Takes a numeric index (n) as an
argument.
• GRL[REPL] - returns a value from the recvpool.gtmrecv_local control block. No argument allowed. Only available when
run on a non-primary instance.
• GSL[REPL] - returns a value from the jnlpool.gtmsource_local_array[n] control block. Takes a numeric index (n) as an
argument.
• JBF[REG]:region[ -obtains fields in shared jnl_buffer structure.
• JNL[REG]:region[ - obtains fields in the jnl_private_control structure.
• JPC[REPL] - returns a value from the jnlpool.jnlpool_ctl control block. No argument allowed.
• NL[REG] - returns a value from the node_local (shared) control block. Takes a case independent region name as an
argument.
• NLREPL - returns a value from the node_local (shared) control block associated with replication. No argument allowed.
Functions
275
• PEEK - returns a value based on the supplied argument. Argument is the base address of the value to obtain in 0xhhhhhhh
format where the h's are hex digits.
• RIH[REPL] - returns a value from the jnlpool.repl_inst_filehdr control block. No argument allowed.
• RPC[REPL] - returns a value from the recvpool.recvpool_ctl control block. No argument allowed. Only available when
run on a non-primary instance.
• UHC[REPL] - returns a value from the recvpool.upd_helper_ctl control block. No argument allowed. Only available when
run on a non-primary instance.
• UPL[REPL] - returns a value from the recvpool.upd_proc_local control block. No argument allowed. Only available when
run on a non-primary instance.
• offset (first integer expression) is a numeric value that specifies the offset from the address supplied or implied by the the
mnemonic and argument. Specifying a negative offset results in a BADZPEEKARG error. Specifying too large an offset such
that unavailable memory is specified results in a BADZPEEKRANGE error.
• length (second integer expression) is a numeric value that specifies the length of the field to obtain. Specifying a negative
legnth results in a BADZPEEKARG error. Specifying a length that exceeds the maximum string length results in a
MAXSTRLEN error. Specifying too large a length such that unavailable memory is specified results in a BADZPEEKRANGE
error.
• format is an optional single case independent character formatting code for the retrieved data. The formatting codes are:
• C : returns a character representations of the memory locations; this is the DEFAULT if the fourth argument is not
specified.
• I : returns a signed integer value - negative values have a preceding minus sign (-); the length can be 1, 2, 4, or 8 bytes.
• U : returns an unsigned integer value - all bits are part of the numeric value; the length can be 1, 2, 4, or 8 bytes.
• S : returns a character representation of the memory locations and the first NULL character found terminates the returned
string; that is: the specified length is a maximum.
• T: Selects a $HOROLOG format for a field of 4 or 8 bytes which is intended for use on fields in UNIX time format (seconds
since 01/01/1970)
• X : returns a hexadecimal value as 0xXXXXXX where XXXXXX is twice the specified length in bytes, so requested length
1 returns 0xXX and length 4 returns 0xXXXXXXXX; the length can be 1, 2, 4, or 8 bytes.
• Z : returns a hexadecimal representation of the memory locations as 'X' does, without regard to endianness, and with no
length restriction other than max string length.
• $ZPEEK() function generates an UNDEF error when VIEW UNDEF is not set and a format parameter is specified but is
undefined.
Notes
• $ZPEEK() has no UTF-8 checking. It is possible for values returned by the 'C' and 'S' codes to have invalid
UTF-8 values in them. Take care when processing values obtained by these codes to either use "VIEW
NOBADCHAR" when dealing with such values and/or use the $Zxxx() flavors of functions like $ZPIECE(),
Functions
276
$ZEXTRACT(),etc which also do not raise BADCHAR errors when encountering invalid UTF-8 encoded
strings.
• Note that $ZPEEK() with 8 byte numeric formatting can return numeric string values that exceed GT.M's
current limit of 18 digits of precision. If the values are used as strings, the extra digits are preserved, but if
used arithmetically, the lower precision digits can be lost.
• When values from replication structures are requested and the structures are not available due to
replication not running or, in the case of the gtmrecv.* control block base options, if not running on a nonprimary instance where the gtmrecv.* control are available, a ZPEEKNOREPLINFO error is raised.
• The JNL[REG] and JBL[REG] mnemonics and characteristics are defined by the running the
GTMDefinedTypesInit.m utility, which produces a cross-index in the form:
gtmtypfldindx(<structure-name>.<field-mnemonic>)=<n>
where gtmtypes(<structure-name>,<n>,*) nodes contain the field characteristics
• When $ZGBLDIR is set to a global directory specifying a replication instance and replication has started,
the Replication Journal Pool for that instance becomes the source of data reported by $ZPEEK(). If a global
directory does not specify a Replication Instance, the gtm_repl_instance environment variable determines
the Instance for its replicated regions. The mnemonics GLF, GSL, JPC, NLREPL, and RIH require a jnlpool.
$VIEW("JNLPOOL") returns the Instance for the current Replication Jounal Pool.
$ZPrevious()
The $ZPREVIOUS function returns the subscript of the previous local or global variable name in collation sequence within
the array level specified by its argument. When $ZPREVIOUS() has an unsubscripted argument, it returns the previous
unsubscripted local or global variable name in collating sequence.
The $ZPREVIOUS function provides compatibility with some other M implementations. The M Development Committee chose
to implement this functionality with the optional second -1 argument of $ORDER(). Therefore, when a design requires this
functionality $ORDER() has the advantage over $ZPREVIOUS of being part of the M standard.
The format for the $ZPREVIOUS function is:
$ZP[REVIOUS](glvn)
• The subscripted or unsubscripted global or local variable name specifies the node prior to which $ZPREVIOUS() searches
backwards for a defined node with data and/or descendants. The number of subscripts contained in the argument implicitly
defines the array level.
• If $ZPREVIOUS() finds no node at the specified level before the specified global or local variable, it returns a null string.
• If the last subscript in the subscripted global or local variable name is null, $ZPREVIOUS() returns the last node at the
specified level.
$ZPREVIOUS() is equivalent to $ORDER() with a second argument of -1.
$ZSOCKET()
Returns information about a SOCKET device and its attached sockets. The format of the $ZSOCKET() function is:
Functions
277
$ZSOCKET(expr1,expr2[,[expr3][,expr4]])
• The first expression specifies the SOCKET device name; an empty string returns the same result as the current device
($IO). If the first expression is not specified, $ZSOCKET() returns information about sockets in the socketpool. Specifying
a device other than a SOCKET device for the $ZSOCKET() function produces a ZSOCKETNOTSOCK error. When a GT.M
process starts with different sockets for input and output on $PRINCIPAL, $ZSOCKET() accepts $ZPIN or $ZPOUT as its
first argument and supplies information on the input or output side, respectively. The following is an example of getting the
handles for the $PRINCIPAL input and output socket devices.
 set handlein=$ZSOCKET($ZPIN,"SOCKETHANDLE",0)
 set handleout=$ZSOCKET($ZPOUT,"SOCKETHANDLE",0)
For more information, refer to “$ZPIN” (page 316) and “$ZPOUT” (page 316).
• The second expression specifies a keyword identifying the type of information returned and the optional third expression
usually specifies the index (starting at zero) of a socket attached to the device; if the index is outside the range of attached
sockets, $ZSOCKET() returns an empty string. If the third expression is not specified, $ZSOCKET() returns information about
the current socket. Using an invalid keyword produces a ZSOCKETATTR error. The fourth expression specifies an individual
delimiter when the second expression specifies DELIMITER. For more information, see the following table. Note that changes
to the socket collection for a SOCKET device using OPEN, CLOSE, USE :ATTACH, or USE :DETACH may change the index
for a socket.
Keyword Arguments Returns
BLOCKING index 1 (TRUE) for blocking otherwise 0 (FALSE)
for non-blocking WRITEs
CURRENTINDEX The index (starting at zero) of the current
socket for the SOCKET device.
DELIMITER index[, delimiter] If only index is specified, the number of
delimiters.
If delimiter is also specified, selects which
delimiter to return. The first delimiter is
zero.
DESCRIPTOR index The OS socket descriptor for the socket.
HOWCREATED index LISTEN, CONNECT, ACCEPTED,
PRINCIPAL, or PASSED
ACCEPTED indicates a connection created
from a LISTENing socket.
PRINCIPAL indicates that the socket is the
$PRINCIPAL of the process.
PASSED indicates a socket passed by
WRITE /ACCEPT.
INDEX handle The current index of the socket named by
handle.
IOERROR index 1 (TRUE) if IOERROR=TRAP otherwise 0
(FALSE).
Functions
278
Keyword Arguments Returns
KEEPALIVE index A non zero value if SO_KEEPALIVE is
enabled.
KEEPCNT index The value of TCP_KEEPCNT.
KEEPIDLE index The value of TCP_KEEPIDLE in seconds.
KEEPINTVL index The value of TCP_KEEPINTVL in seconds.
LOCALADDRESS index The address of the local side of the socket.
For TCP sockets: the IPv6 or IPv4 numeric
address. For LOCAL sockets: the path.
LOCALPORT index The numeric port of the local side of a TCP
socket.
MOREREADTIME index The value of the MOREREADTIME device
parameter if it was specified, otherwise an
empty string.
NUMBER The number of sockets in the SOCKET
device.
OPTIONS index a string of the “OPTIONS” (page 404)
previously specified for the selected socket.
The string may not exactly match the
string originally specified but has the same
meaning.
PARENT index If the socket was created from a LISTENing
socket: the handle of the LISTENing socket.
PROTOCOL index TCP, TCP6, or LOCAL
REMOTEADDRESS index The address of the remote side of the socket.
For TCP sockets: the IPv6 or IPv4 numeric
address. For LOCAL sockets: the path.
REMOTEPORT index The numeric port of the remote side of a
TCP socket.
SNDBUF index Size of the OS send buffer in bytes
(SO_SNDBUF).
SOCKETHANDLE index The handle for the selected socket.
STATE index One of LISTENING, CONNECTED, BOUND,
or CONNECTINPROGRESS
TLS index[,expr4] If the selected socket is using TLS, a string
of the form: 1,{SERVER|CLIENT}[,tlsid],
where the optional tlsid comes from the
WRITE /TLS which enabled TLS on the
socket; otherwise an empty string. See
the following table for a description of all
options for the fourth expression for the TLS
keyword.
Functions
279
Keyword Arguments Returns
ZBFSIZE index Size of the GT.M buffer in bytes.
ZFF index The value of the ZFF device parameter.
ZIBFSIZE index Size of the OS buffer in bytes (SO_RCVBUF).
ZDELAY index 1 if Nagle algorithm enabled, otherwise 0.
Note
The getsockopt() keywords (KEEPALIVE, KEEPCNT, KEEPIDLE, KEEPINTVL, SNDBUF, and ZIBFSIZE
return two values if the value previously specified with the “OPTIONS” (page 404) or "ZIBFSIZE"
device parameter doesn't match the system's current value. The two values are separated by a semicolon
(";"):"uservalue;systemvalue".
The following table describes the values for the fourth expression for the TLS keyword.
expr4 (TLS) Description
SESSION Returns information related to SSL sessions including information about renegotiations. Here is
an example:
|S:RENSEC:1,RENTOT:1,SESSID:<SESSID>, SESEXP:Thu Jun 4 21:07:11 2015
"|S:" denotes this piece contains session information, "RENSEC:" indicates whether secure
renegotiation is available (1) or not (0), "RENTOT:" gives the current total number of
renegotiations done on this socket, "SESSID:" shows the session id in hexadecimal, and
"SESEXP:" indicates when the session expires respresented as time in the local time zone.
OPTIONS the hexadecimal representation of the ssl-options selected by the combination of the OpenSSL
defaults, options set by the GT.M TLS plugin, and options specified in the gtmcrypt_config
configuration file prefixed by "O:", a comma, and the verify mode as two hexadecimal digits. Here
is an example:
|O:0000000001520004,01
The values for the SSL_OP options and verify modes are defined in the include/openssl/ssl.h file
provided by the OpenSSL development package.
Note: the TLS reference implementation plug-in disables protocols prior to TLSv1.2.
CIPHER The SSL protocol version prefixed by "P:" and the algorithm negotiated between the server and
client prefixed by "C:". Here is an example:
|P:TLSv1.2|C:DHE-RSA-AES256-SHA
ALL returns all available information. Here is an example:
|P:TLSv1.2|C:AES256-GCM-SHA384|O:0000000001020004,01|
S:RENSEC:1,RENTOT:0,SESEXP:Mon Jun 22 23:58:09 2015
Functions
280
$ZSYSLOG()
Sends its string parameter to the system log and always returns TRUE (1). The text appears in the syslog with the same format
as any other GT.M syslog message (that is, in the user.info log with GTM-MUMPS[pid]" or "GTM-MUPIP[pid]" prefix along
with instance information where appropriate). The format of the $ZSYSLOG function is:
$ZSYSLOG(expr)
$ZQGBLMOD()
The $ZQGBLMOD function enables an application to determine whether it can safely apply a lost transaction to the database.
A lost transaction is a transaction that must be rolled off a database to maintain logical multisite consistency. $ZQGBLMOD()
always applies to data-level (level-0) nodes.
The format for the $ZQGBLMOD function is:
$ZQGBLMOD(gvn)
• The subscripted or non-subscripted global variable name (gvn) specifies the target node.
• A return value of zero (0) means the value of the global variable has not changed since the last synchronization of the
originating and replicating instances.
• A return value of one (1) means the value of the global variable may have changed since the last synchronization of the
originating and replicating instance.
$ZQGBLMOD function produces an error if you submit an argument that is not a global variable name.
Internally, $ZQGBLMOD (gvn) compares the GT.M transaction number in the database block in which the global variable name
is (or would be) stored with the value in the Zqgblmod_Trans field stored in the database file header.
For example, if x is the transaction number of the level-0 database block in which gvn resides, and y is the value of
Zqgblmod_Trans of region reg containing gvn, then the following is true:
• If x <= y, no transaction modified the level-0 database block z in which gvn resides since the originating and replicating
instances synchronized with each other. $ZQGBLMOD() returns a zero (0).
• If x > y, some transaction modified z, but not necessarily gvn, after the originating and replicating instances synchronized
with each other. $ZQGBLMOD() returns a one (1).
If a transaction is a lost transaction that has been rolled back and it is determined that for all the M globals set and killed in the
transaction $ZQGBLMOD() is zero (0), it is probably safe to apply the updates automatically. However, this determination of
safety can only be made by the application designer and not by GT.M. If the $ZQGBLMOD() is one (1) for any set or kill in the
transaction, it is not safe to apply the update.
Note
The test of $ZQGBLMOD() and applying the updates must be encapsulated inside a GT.M transaction.
Another approach to handling lost transactions would be to store in the database the initial message sent by a client, as well
as the outcome and the response, and to reprocess the message with normal business logic. If the outcome is the same, the
transaction can be safely applied.
Functions
281
Note
If restartable batch operations are implemented, lost batch transactions can be ignored since a subsequent
batch restart will process them correctly.
$ZSEARCH()
The $ZSEARCH function attempts to locate a file matching the specified file name. If the file exists, it returns the file name; if
the file does not exist, it returns the null string.
The format for the $ZSEARCH function is:
$ZSEARCH(expr[,intexpr])
• The expression contains a file name, with or without wildcards, for which $ZSEARCH() attempts to locate a matching file.
Repeating $ZSEARCH with the same filename uses the same context and return a sequence of matching files when they
exist; when the sequence is exhausted, $ZSEARCH() returns an empty string (""). Any change to the file name starts a new
context.
• $ZSEARCH() uses the process current working directory, if the expression does not specify a directory.
• The optional integer expression specifies a "stream" number from 0 to 255 for each search; streams provide a means of having
up to 256 $ZSEARCH() contexts simultaneously in progress.
• If a $ZSEARCH() stream has never been used or if the expression differs from the argument to the last $ZSEARCH() of the
stream, the function resets the context and returns the first pathname matching the expression; otherwise, it returns the next
matching file in collating sequence; if the last prior pathname returned for the same expression and same stream was the last
one matching the argument, $ZSEARCH() returns a null string.
$ZSEARCH() provides a tool for verifying that a file exists. For information to help determine the validity of a file name, see
“$ZPARSE()” (page 270).
Note
You can call the POSIX stat() function to access metadata. The optional GT.M POSIX plug-in packages the
stat() function for easy access from M application code.
Examples of $ZSEARCH()
Example:
GTM>write $zsearch("data.dat")
/usr/staff/ccc/data.dat
GTM>
This uses $ZSEARCH() to display the full file path name of "data.dat" in the process current default directory.
Example:
GTM>set x=$zsearch("*.c")
Functions
282
GTM>for set x=$zsearch("*.m") quit:x="" write !,$zparse(x,"NAME")
This FOR loop uses $ZSEARCH() and $ZPARSE() to display M source file names in the process current working directory. To
ensure that the search starts at the beginning, the example resets the context by first searching with a different argument.
$ZSIGPROC()
Sends a signal to a process. The format for the $ZSIGPROC function is:
$ZSIGPROC(expr1,expr2)
• The first expression is the pid of the process to which the signal is to be sent.
• The second expression is the system signal number. Because a signal number of a signal name can be different
for various platforms, FIS recommends using signal names to maintain code portability across different platforms.
For example, the signal number for SIGUSR1 is 10 on Linux, 30 on AIX, and 16 for some other platforms. Use the
$&gtmposix.signalval(signame,.sigval) function available in the gtmposix plugin to determine the signal number of a signal
name.
• If the second expression is 0, $ZSIGPROC() checks the validity of the pid specified in the first expression.
• There are four possible return values from $ZSIGPROC():
Return codes/POSIX Error Definitions Description
0 The specified signal number was successfully sent to the specified
pid. Any return value other than 0 indicates an error.
EPERM The process has insufficient permissions to send the signal to the
specified pid.
ESRCH The specified pid does not exist.
EINVAL Invalid expression(s).
Caution
Although $ZSIGPROC() may work today as a way to invoke the asynchronous interrupt mechanism of GT.M
processes to XECUTE $ZINTERRUPT because the underlying mechanism uses the POSIX USR1 signal, FIS
reserves the right to change the underlying mechanism to suit its convenience and sending a POSIX USR1
may cease to work as a way to invoke the asynchronous interrupt mechanism. Use MUPIP INTRPT as the
supported and stable API to invoke the asynchronous interrupt mechanism.
Examples of $ZSIGPROC()
Example:
GTM>job ^Somejob
GTM>set ret=$&gtmposix.signalval("SIGUSR1",.sigusr1) zwrite
ret=0
sigusr1=10
GTM>write $zsigproc($zjob,sigusr1)
Functions
283
0
GTM>
This example sends the SIGUSR1 signal to the pid specified by $zjob.
$ZSUBstr()
Returns a properly encoded string from a sequence of bytes.
$ZSUB[STR] (expr ,intexpr1 [,intexpr2])
• The first expression is an expression of the byte string from which $ZSUBSTR() derives the character sequence.
• The second expression is the starting byte position (counting from 1 for the first position) in the first expression from where
$ZSUBSTR() begins to derive the character sequence.
• The optional third expression specifies the number of bytes from the starting byte position specified by the second
expression that contribute to the result. If the third expression is not specified, the $ZSUBSTR() function returns the sequence
of characters starting from the byte position specified by the second expression up to the end of the byte string.
• The $ZSUBSTR() function never returns a string with illegal or invalid characters. With VIEW "NOBADCHAR", the
$ZSUBSTR() function ignores all byte sequences within the specified range that do not correspond to valid UTF-8 codepoints. With VIEW "BADCHAR", the $ZSUBSTR() function triggers a run-time error if the specified byte sequence contains a
code-point value that is not in the character set.
• The $ZSUBSTR() is similar to the $ZEXTRACT() byte equivalent function but differs from that function in restricting its
result to conform to the valid characters in the current encoding.
Examples of $ZSUBSTR()
Example:
GTM>write $ZCHSET
M
GTM>set char1="a" ; one byte character
GTM>set char2="ç"; two-byte character
GTM>set char3="新"; three-byte character
GTM>set y=char1_char2_char3
GTM>write $zsubstr(y,1,3)=$zsubstr(y,1,5)
0
With character set M specified, the expression $ZSUBSTR(y,1,3)=$ZSUBSTR(y,1,5) evaluates to 0 or "false" because the
expression $ZSUBSTR(y,1,5) returns more characters than $ZSUBSTR(y,1,3).
Example:
GTM>write $zchset
UTF-8
GTM>set char1="a" ; one byte character
GTM>set char2="ç"; two-byte character
GTM>set char3="新"; three-byte character
GTM>set y=char1_char2_char3
GTM>write $zsubstr(y,1,3)=$zsubstr(y,1,5)
Functions
284
1
For a process started in UTF-8 mode, the expression $ZSUBSTR(y,1,3)=$ZSUBSTR(y,1,5) evaluates to 1 or "true" because the
expression $ZSUBSTR(y,1,5) returns a string made up of char1 and char2 excluding the three-byte char3 because it was not
completely included in the specified byte-length.
In many ways, the $ZSUBSTR() function is similar to the $ZEXTRACT() function. For example, $ZSUBSTR(expr,intexpr1) is
equivalent to $ZEXTRACT(expr,intexpr1,$L(expr)). Note that this means when using the M character set, $ZSUBSTR() behaves
identically to $EXTRACT() and $ZEXTRACT(). The differences are as follows:
• $ZSUBSTR() cannot appear on the left of the equal sign in the SET command where as $ZEXTRACT() can.
• In both the modes, the third expression of $ZSUBSTR() is a byte, rather than character, position within the first expression.
• $EXTRACT() operates on characters, irrespective of byte length.
• $ZEXTRACT() operates on bytes, irrespective of multi-byte character boundaries.
• $ZSUBSTR() is the only way to extract as valid UTF-8 encoded characters from a byte string containing mixed UTF-8 and non
UTF-8 data. It operates on Unicode® characters so that its result does not exceed the given byte length.
$ZTRanslate()
Returns a byte sequence that results from replacing or dropping bytes in the first of its arguments as specified by the patterns of
its other arguments.
The format for the $ZTRANSLATE() function is:
$ZTR[ANSLATE](expr1[,expr2[,expr3]])
• The first expression specifies the sequence of octets on which $ZTRANSLATE() operates. If the other arguments are omitted,
$ZTRANSLATE() returns this expression.
• The optional second expression specifies the byte for $TRANSLATE() to replace. If a byte occurs more than once in the
second expression, the first occurrence controls the translation, and $ZTRANSLATE() ignores subsequent occurrences. If this
argument is omitted, $ZTRANSLATE() returns the first expression without modification.
• The optional third expression specifies the replacement bytes for the positionally corresponding bytes in the second
expression. If this argument is omitted or shorter than the second expression, $ZTRANSLATE() drops all occurrences of the
bytes in the second expression that have no replacement in the corresponding position of the third expression.
• $ZTRANSLATE() provides a tool for tasks such as encryption.
The $ZTRANSLATE() algorithm can be understood as follows:
• $ZTRANSLATE() evaluates each byte in the first expression, comparing it byte by byte to the second expression looking for a
match. If there is no match in the second expression, the resulting expression contains the byte without modification.
• When it locates a byte match, $ZTRANSLATE() uses the position of the match in the second expression to identify the
appropriate replacement for the original expression. If the second expression has more bytes than the third expression,
$ZTRANSLATE() replaces the original byte with a null, thereby deleting it from the result. By extension of this principle,
if the third expression is missing, $ZTRANSLATE() deletes all bytes from the first expression that occur in the second
expression.
Functions
285
Examples of $ZTRANSLATE()
Example:
GTM>set hiraganaA=$char(12354) ; $zchar(227,129,130)
GTM>set temp1=$zchar(130)
GTM>set temp2=$zchar(140)
GTM>set tr=$ztranslate(hiraganaA,temp1,temp2)
GTM>w $ascii(tr)
12364
GTM>
In the above example, $ZTRANSLATE() replaces byte $ZCHAR(130) in first expression and matching the first (and only) byte in
the second expression with byte $ZCHAR(140) - the corresponding byte in the third expression.
$ZTRIgger()
Examine or load trigger definition. The format of the $ZTRIGGER() function is:
$ZTRIgger(expr1[,expr2])
• $ZTRIGGER() returns a truth value (1 or 0) depending on the success of the specified action.
• $ZTRIGGER() performs trigger maintenance actions similar those performed by MUPIP TRIGGER.
• If expr1 evaluates to case-insensitive "FILE", $ZTRIGGER() evaluates expr2 as the location of the trigger definition file. Then,
it applies the trigger definitions in the file specified by expr2. If a file contains a delete all (-*), that action produces no user
confirmation.
• If expr1 evaluates to case-insensitive "ITEM", $ZTRIGGER() evaluates expr2 as a single line or multi-line trigger definition
entry. A multi-line trigger definition or a multi-line XECUTE string starts with << and uses $char(10) to denote the newline
separator. expr2 with ITEM does not permit a multi-line XECUTE string to end with the >> terminator. It does not require
trigger logic to appear immediately after the -xecute=<<, but a $char(10) must prefix the logic as shown in the following
examples:
set trigstr="+^a -xecute=<< -commands=S"_$char(10)_" do ^twork1"_$char(10)_" do ^twork2"_$char(10) write
 $ztrigger("item",trigstr)
set trigstr="+^a -xecute=<< -commands=S "_$c(10)_" do ^twork1"_$c(10)_" do ^twork2"_$c(10) write
 $ztrigger("item",trigstr)
• If expr1 evaluates to case-insensitive "SELECT", $ZTRIGGER() evaluates the optional expr2 as a trigger name or name
wildcard, and directs its output to $IO. A FALSE result (0) indicates there are no matching triggers.
• $ZTRIGGER() always operates within a TP transaction even if it needs to implicitly create one to encapsulate its work.
Trigger maintenance operations reserve their output until the transaction commits (TCOMMIT where $TLEVEL goes
to zero), at which time they deliver their entire output to the current $IO containing consistent information for all
$ZTRIGGER() invocations within the successful processing of a larger transaction at that ultimate TCOMMIT. If an explicit
transaction ends with a TROLLBACK, it does not produce any $ZTRIGGER() output.
• $ZTRIGGER() can appear within a transaction as long as it does not update any triggers for globals which have had triggers
invoked earlier in the same transaction.
Functions
286
• An attempt by a $ZTRIGGER() within a transaction to remove or replace a trigger on a global after the transaction has
activated any trigger defined within the named global generates a TRIGMODINTP error.
• $ZTRIGGER() treats the deletion of a non-existent trigger as a success; if that is the only operation, or one of a set of
successful operations, it return success (TRUE/1) to the GT.M process. $ZTRIGGER() returns failure in case of trigger
selection using trigger names where the number after the pound-sign (#) starts with a 0 (which is an impossible autogenerated trigger name).
• GT.M maps trigger definitions to the region to which they apply.
• GT.M allows defining triggers with the same name and signature in different regions, but does not allow defining triggers
with the same name, but different signatures, in different regions within the same global directory. When loading a trigger
definition, if a user-defined name conflicts with a name in any region to which the trigger applies, $ZTRIGGER() reports an
error. However, when the name is auto-generated, it generates a name in every region, so if there are multiple (spanning)
regions, the same trigger might have a differing auto-generated name in each region.
Note
A $ZTRIGGER() action (delete or select) applies to all triggers in all regions matching the specified signature.
If the argument specifies an incomplete trigger signature, for example, only the name, the specification may
match multiple triggers and apply the delete or select to all of them. FIS recommends you run a select and
analyze the scope of the signature before any signature limited delete.
Examples of $ZTRIGGER()
Example:
GTM>set X=$ztrigger("S")
GTM>
This example displays the current trigger definitions stored in the database.
GTM>set X=$ztrigger("i","+^Acct(sub=:) -command=set -xecute=""set ^X($ztvalue)=sub""")
GTM>
This example adds a trigger definition for the first level node of ^Acct.
Example:
GTM>set trigstr="+^a -commands=S -xecute=<<"_$c(10)_" do ^twork1"_$c(10)_" do ^twork2"_$c(10) write $ztrigger("item",trigstr)
This example demonstrates the usage of the $ztrigger("ITEM",<multi-line-trigger-definition>> where <<denotes the
definition of a multi-line -XECUTE string and $c(10) to denote the newline separator. Unlike the $ztrigger("FILE") form,
$ztrigger("ITEM",<multi-line-trigger-definition>> does not require the trigger definition to terminate with >>.
Example:
GTM>write $ztrigger("file","agbl.trg")
1
GTM>
This example is equivalent to the previous $ztrigger("ITEM") example. In this example, agbl.trg contains the following multiline trigger definition:
Functions
287
+^a -commands=S -xecute=<<
 do ^twork1
 do ^twork2
>>
Unlike $ztrigger("ITEM"), $ztrigger("FILE") usages require the trigger definition to terminate with >>
$ZTRNLNM()
The $ZTRNLNM function returns the value of an environment variable.The $ZTRNLNM function is analogous to the DCL
Lexical function F$TRNLNM on OpenVMS.
Note
$ZTRNLNM() does not perform iterative translation.
The format for the $ZTRNLNM function is:
$ZTRNLNM(expr1[,expr2[,expr3[,expr4[,expr5[,expr6]]]]])
expr1 specifies the environment variable whose value needs to be returned.
expr2 to expr5 are OpenVMS-related expressions that specify logical name table(s), index (numbered from 0), initial mode of the
look-up, and a value indicating whether the look-up is case sensitive. To ensure interoperability between UNIX and OpenVMS
versions, $ZTRNLNM() on UNIX accepts these expressions and ignores them.
The optional expr6 specifies any one of the following keywords:
ITEM KEYWORD DATA RETURNED
FULL Returns the translation.
LENGTH Length of the return value in bytes.
VALUE Returns the translation.
Examples of $ZTRNLNM()
Example:
GTM>write $ztrnlnm("gtm_dist","","","","","VALUE")
/usr/lib/fis-gtm/V6.3-004_x86_64/utf8
GTM>write $ztrnlnm("gtm_dist")
/usr/lib/fis-gtm/V6.3-004_x86_64/utf8
GTM>
These example use $ZTRNLNM() to display the translation value for gtm_dist.
$ZWidth()
Returns the numbers of columns required to display a given string on the screen or printer. The format of the $ZWIDTH()
function is:
Functions
288
$ZW[IDTH] (expr)
• The expression is the string which $ZWIDTH() evaluates for display length. If the expression contains a code-point value
that is not a valid UTF-8 character, $ZWIDTH() generates a run-time error.
• If the expression contains any non-graphic characters, the $ZWIDTH() function does count not those characters.
• If the string contains any escape sequences containing graphical characters (which they typically do), $ZWIDTH() includes
those characters in calculating its result, as it does not do escape processing. In such a case, the result many be larger than
the actual display width.
With character set UTF-8 specified, the $ZWIDTH() function uses the ICU's glyph-related conventions to calculate the number
of columns required to represent the expression.
Note
When in "NOBADCHAR" mode, $ZWIDTH() returns give any bad characters a length of zero (0), which may
or may not match the behavior of any device used to display the string.
Examples of $ZWIDTH()
Example:
GTM>set NG=$char($$FUNC^%HD("200B"))
GTM>set S=$char(26032)_NG_$CHAR(26033)
GTM>W $ZWidth(S)
4
GTM>
In the above example, the local variable NG contains a non-graphic character which does not display between two doublewidth UTF-8 characters.
Example:
GTM>write $zwidth("The rain in Spain stays mainly in the plain.")
44
GTM>set A="主要雨在西班牙停留在平原"
GTM>write $length(A)
12
GTM>write $zwidth(A)
24
In the above example, the $ZWIDTH() function returns 24 because each character in local variable A occupies 2 columns when
they are displayed on the screen or printer.
$ZWRite()
Converts its first string argument to or from ZWRITE format (quoted graphics characters concatenated with $CHAR()
representations of any non-graphic characters). The second integer expression controls the direction of conversion. The format
of the $ZWRITE() function is:
$ZWRITE(expr[,intexpr])
• The first argument specifies the string to convert to or from the ZWRITE format.
Functions
289
• The second argument specifies the direction of conversion. When intexpr is not specified or evaluates to zero, $zwrite()
converts the first argument to the ZWRITE format. When intexpr evaluates to a non-zero value, $ZWRITE() treats the first
argument as being in ZWRITE format and attempts to convert it to a string with embedded non-graphic characters; if it is not
in ZWRITE format, it returns an empty string.
• Converting to zwrite format tends to produce a string that is longer than the input and therefore a $ZWRITE() result may
exceed the maximum string length - the maximum input length that is guaranteed not to do so is a 116,510 byte string.
• If all its arguments are literals, $ZWRITE() evaluates to a literal constant at compile time.
• Note that non-graphic characters differ between M mode and UTF-8 mode.
Example:
GTM>set temp="X"_$char(10)_"X" ; $CHAR(10) is the linefeed character
GTM>write temp
X
X
GTM>write $zwrite(temp)
"X"_$C(10)_"X"
GTM>write $zwrite($zwrite(temp),1)
X
X
GTM>           
                

                </code>
              </pre>
            </q-card-section>
            </div>
            </template>
            </q-splitter>
          
        </q-card>
      </q-dialog>
      <q-dialog v-model="learnmpgdialog" persistent :maximized="maximizedTogglepg" transition-show="slide-up" transition-hide="slide-down">
        <q-card class="bg-black text-red full-width">
          <q-bar>
            <q-space></q-space>
            <q-btn dense flat icon="minimize" @click="maximizedpgToggle=false">
            </q-btn>
            <q-btn dense flat icon="crop_square" @click="maximizedpgToggle=true">
            </q-btn>
            <q-btn dense flat icon="close" @click="learnmpgdialog=false"></q-btn>
          </q-bar>
          <q-card-section>
            <div class="text-h3">M Programming Guide</div>
          <div style="maximizedpgToggle===true?'height:90vh;width:90vw;':'height:75vh;width:75vw;'"> 
            <iframe style="'height:75vh;width:75vw;'" src="https://github.com/aa32555/efuzy.com/blob/staging/docs/GT.M%20Programmers%20Guide.pdf">
            </iframe>
          </div>
          </q-card-section>
        </q-card>
      </q-dialog>

 <q-dialog v-model="mystorydialog" :maximized="true" transition-show="slide-up" transition-hide="slide-down">
        <q-card class="bg-black text-red full-width">
           <q-bar>
            <q-space></q-space>
            <q-btn dense flat icon="close" @click="mystorydialog = false"></q-btn>
          </q-bar>
 <div class="q-px-lg q-pb-md">
    <q-timeline color="red">
      <q-timeline-entry heading>
        Timeline heading
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 22, 1986"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 21, 1986"
        icon="delete"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>

      <q-timeline-entry heading>
        November, 2017
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 22, 1986"
        avatar="https://cdn.quasar.dev/img/avatar2.jpg"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 22, 1986"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 22, 1986"
        color="orange"
        icon="done_all"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 22, 1986"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>

      <q-timeline-entry
        title="Event Title"
        subtitle="February 22, 1986"
      >
        <div>
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </div>
      </q-timeline-entry>
    </q-timeline>
  </div>
</q-card></q-dialog>
      <script>
        window.quasarConfig = {
          dialog: {},
          notify: {},
          loading: {},
          loadingBar: {},
          fullscreen: {}
        }
      </script>
      <script src="https://cdn.jsdelivr.net/npm/quasar@1.22.10/dist/quasar.ie.polyfills.umd.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/vue@^2.0.0/dist/vue.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/quasar@1.22.10/dist/quasar.umd.modern.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
      <script>
  new Vue({
          el: '#q-app',
          data: function() {
            return {
              modalimg:'',
              imgdialog:false,
              sessionIsteppermodel:1,
              sessionIdialog:false,
              editor:'',
              splitterModel:50,
              showsd:true,
              bgn:2,
              hostc:'',
              bgc:'https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b2.png',
              bgs:'',
              bg1:'https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b1.png',
              bg2:'https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/b2.png',
              bg3:'https://raw.githubusercontent.com/aa32555/efuzy.com/staging/docs/bgd.jpg',
              host:'ahmed',
              sd:true,
              showjoshua:false,
              currentTimestamp:'',
              currentText:'',
              showAA:false,
              spinnerdotstext:'',
              showspinnerdots:false,
              mystorydialog:false,
              showISISes:[false,false,false],
              showISIST: [false,false,false],
              messagesISIS0: [],
              messagesISIS1:[],
              currentGuest:'',
              maximizedpgToggle:false,
              ti2: '',
              mtabsbooted: false,
              mtabs: 'zp',
              maximizedToggle: true,
              maximizedTogglepg: true,
              tab2: 'dollarp',
              learnmdialog: false,
              learnmpgdialog: false,
              ti: '',
              tab: '',
              theme: 'light',
              fab: '',
              showRA: false,
              showBASTET: false,
              showME: false,
              showISIST: false,
              showISIS: false,
              showRAT: false,
              t: null,
              termExists: false,
              showTerm: false,
              label: 'test',
              staticlottie: true,
              lottiekey: '1',
              speed: 1.5,
              chatText: '',
              splitterModel: 50,
              messages: [],
              showTyping: false,
              messageNumber: -1,
              messageDirection: true,
              showReply: false,
              termiibooted: false,
              showaa1:true,
              rharr: [
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
             ],
             bsmnharr: [
             '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              `Yo, Big Shaq, the one and only\nMan's not hot, never hot\nSkrrat (GottiOnEm), skidi-kat-kat\nBoom`,
              'Two plus two is four',
              'Minus one that\'s three, quick maths',
              'Everyday man\s on the block',
              'Smoke trees (Ah)',
              'See your girl in the park',
              'That girl is a uckers',
              'When the ting went quack-quack-quack',
              'You man were ducking',
              'Hold tight, Asznee',
              'I said, "Babes,',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓇋𓀀𓀁𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              '𓄿𓀅𓀅𓆲𓀀𓇋𓀁𓀅𓀅𓀅𓀀𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅𓄿𓀅𓀅𓀅𓀀𓀁𓇋𓀅𓀀𓇋𓀁𓀅',
              'There once was a little girl','Who had a crush on a bad, bad boy','But when that bad boy got out of prison','That little girl\'s ass was in big, big trouble',
                'Daai bra Anies, hy\'s \'n fokken gam bra','Haai! Daai Anies, hy lam innie mang, ja','"Ken sy my nommer?" Xha! Boy, what\'s your number?','Twee ses? Twee sewe? Of is jy \'n ag bra?',
                'Throw them devilish gang signs in the air',
                'Start giving it up for little evil me',
                'My fingers are green \'cause I\'m a mean dope fiend',
                'I\'m wicked like a mad D.O.G.',
                'Fresh like a little dark G.O.D.',
                'Yo-Landi Vi$$er got the hypest flow',
                'Start talking in tongues whenever I get stoned',
                'Motherfucking minds get blown',
                'Every time I rap into the microphone',
                'My zef accent is very foreign',
                'When I speak overseas they go "I beg your pardon?"',
                'You can\'t get me, like Eric Cartman',
                'Naughty little kitty go "meow"',
    
             ],
             yctarr:[
                'There once was a little girl','Who had a crush on a bad, bad boy','But when that bad boy got out of prison','That little girl\'s ass was in big, big trouble',
                'Daai bra Anies, hy\'s \'n fokken gam bra','Haai! Daai Anies, hy lam innie mang, ja','"Ken sy my nommer?" Xha! Boy, what\'s your number?','Twee ses? Twee sewe? Of is jy \'n ag bra?',
                'Throw them devilish gang signs in the air',
                'Start giving it up for little evil me',
                'My fingers are green \'cause I\'m a mean dope fiend',
                'I\'m wicked like a mad D.O.G.',
                'Fresh like a little dark G.O.D.',
                'Yo-Landi Vi$$er got the hypest flow',
                'Start talking in tongues whenever I get stoned',
                'Motherfucking minds get blown',
                'Every time I rap into the microphone',
                'My zef accent is very foreign',
                'When I speak overseas they go "I beg your pardon?"',
                'You can\'t get me, like Eric Cartman',
                'Naughty little kitty go "meow"',
              ],
              xx1:'An alien represented in an 1987 Arnold Movie',
              xx2:'An Ancient Egiyptian Diety named AMIT, ( As in The first letter of our sacred languages\'s alphabet',
              xx3:'احمد خالد محمد عبد الرازق حفيد القبطان البكري الله يمسيه بالخير',
              xx4:'٤٩ אותיות',
              xx5:'comment dit-on Macron en français',
              xx6:'cat-woman-named-bastet-meow[4now]',
              xx7:'Goddess ISIS () Goddess of Love ()',
              xx8:'George Grodentzik',
              xx9:'Pornstar (I befriended) that looks like Goerge\'s dauther, but tall and pretty and not a jew',
            }
          },
          mounted: async function() {
         let _vm = this;
            _vm.xtermLoad();
            _vm.$q.dark.set(true);
            let t = window['term'];
            let a;        
            t.options.scrollLines=1000;
            t.options.scrollPages=1000
            let x = 0;
            let bgn = function(){
             return x=x+(_vm.ttime()*750);
            }
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;30m'   +  'hello...!!!!!!!!                              ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;30m'   +  '....is anyone there?!!!!                      ' +'\x1B[0m');t.focus();},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;30m'   +  '                          اي حد هنا!!! ... الو' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;30m'   +  'I need help!!!!!!!!!!!!                       ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑ ɑ   ɑ ɑ   ɑ ɑ   ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑ ɑ   ɑ     ɑ ɑ ɑ ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑ ɑ   ɑ ɑ   ɑ ɑ   ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ       ɑ     ɑ ɑ ɑ ɑ   ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ       ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ       ɑ     ɑ ɑ ɑ ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑ ɑ   ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
bgn();setTimeout(function(){_vm.host='joshua';t.scrollToBottom();t.writeln('\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑ ɑ   ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑɑɑɑɑɑɑɑ'+'\x1B[0m');},x);
            //
           _vm.sd=false;x=x+2000;setTimeout(function(){t.scrollToBottom();t.focus();},x);
            //
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'                    /\\                         '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'                   /  \\                        '+'\x1B[0m');t.scrollToBottom();},x);              
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'                  /    \\                       '+'\x1B[0m');t.scrollToBottom();},x);       
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'                 / <()> \\                      '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'                /________\\                     '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'               /__________\\                    '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'              /____________\\                   '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'             /______________\\                  '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'            /________________\\                 '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'           /__________________\\                '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'          /__I___I___I___I_____\\               '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[1;30;103m'+'         /_I___I___I___I___I____\\              '+'\x1B[0m');t.scrollToBottom();},x);

            //
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[30;103m'+'                                       اصحابك جاين'+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[30;103m'+'                         اصبر شوية. انت توهت تاني؟'+'\x1B[0m');t.scrollToBottom();},x);
            //
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[30;107m'+'translation:your friends are comming              '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[30;107m'+'translation:be a little patient, did you          '+'\x1B[0m');t.scrollToBottom();},x);
bgn();setTimeout(function(){_vm.host='bastet';t.scrollToBottom();t.writeln('\x1B[30;107m'+'translation: get lost again?                      '+'\x1B[0m');t.scrollToBottom();},x);
            //
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ '                                                آْه'+'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ '                              المرة دى مختلفة خالس'+'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ '                               لاول مرة وانا خايف'+'\x1B[0m');t.focus();;},x);
            //
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ 'translation:Yess                                  ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ 'translation:this time it\'s very different        ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ 'translation:I\'m scared for the first time        ' +'\x1B[0m');t.focus();;},x);
            //
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ '                        عازيني اتعلم لغة حاسوب آلي' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ '               المؤمنه تأميناً كامل بال بريداتور جُد' +'\x1B[0m');t.focus();;},x);
            //
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ 'translation:They want me to learn...              ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ 'translation:a computer programming language       ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='ahmed';t.scrollToBottom();t.writeln('\x1B[107;97m'+ 'translation:that is protected by Predator God.    ' +'\x1B[0m');t.focus();;},x);
bgn();setTimeout(function(){_vm.host='';_vm.showsd=false;},x);
          //
          //  x=x+5000;setTimeout(function(){t.scrollToBottom();t.focus();t.clear();;_vm.bgs=_vm.bg1;_vm.host='';_vm.showaa1=true;_vm.showsd=false;},x);
          },
          methods: {
            learnm: function() {
              this.learnmdialog = true
              this.xtermciLoad();
            },
            learnmpg: function() {
              this.learnmpgdialog = true
            },
            submit: function() {
              window['term'].write(this.ti);
            },
            changeTheme: function() {
              if (this.theme === "light") {
                this.$q.dark.set(true);
                this.theme = "dark";
              } else {
                this.$q.dark.set(false);
                this.theme = "light";
              }
            },
            focus: function() {
              window['term'].focus();
            },
            xtermInitialize: function() {},
            xtermBoot: function() {
              this.termExists = true;
              let term = window['term'] || new Terminal({
                cursorBlink:true,
                convertEol:false,
                fontSize:26,
               // cols:80,
               // row:80,
                allowTransparency:true,
                cursorStyle:'block',
                cursorInactiveStyle:'bar',
              });
              this.term = term;
              window['term'] = term;
              term.open(document.getElementById('terminal'));
              this.showTerm = true;
            },
            w: function(a) {
              this.term.write('\r\n' + a);
            },
            porocessNotes: function(){
              window['term2'].write(this.editor);
            },//'\x1B[1;30;101m'+  'ɑ ɑ   ɑ ɑ ɑ ɑ ɑ ɑ ɑ   ɑ ɑ   ɑ ɑ   ɑ ɑ '+'\x1B[0m'
            startSessionI: function(){
              window['term2'].clear();
              window['term2'].focus();
              let _vm = this;
              window['term2'].writeln('\x1B[1;30;101m'+ '         Start Session I is about to start           '+'\x1B[0m')
            setTimeout(function(){
              window['term2'].writeln('\x1B[1;30;101m'+ '         predator God wants us to start w/ $p        '+'\x1B[0m')
              window['term2'].writeln('\x1B[1;30;101m'+ '         something MAGICAL is going to happen        '+'\x1B[0m')
              window['term2'].writeln('\x1B[1;30;101m'+ '         if you click [1;30;103mTHE BUTTON] below.              '+'\x1B[0m')
            },3000)
            /*
           setTimeout(function(){
             window['term2'].writeln('\x1B[1;30;101m'+ '                         NOW                          '+'\x1B[0m',function(){
               
             })
            },10000)
            */
            },
            xtermLoad: function() {
              this.xtermBoot();
            },
            processmtabs: function() {
                window['term2'].clear();
                setTinmeout(function(){
              window['term2'].write(window[this.mtabs].join('\r\n'));

               setTinmeout(function(){window['term2'].focus();});
                })       
            },
            xtermciLoad: function() {
              let _vm = this;
              setTimeout(function() {
                let term2;
                if (typeof window['term2'] === 'undefined') {
                  term2 = window['term2'] || new Terminal({
                cursorBlink:true,
                convertEol:false,
                fontSize:26,
                cols:60,
                row:640,
                allowTransparency:true,
                cursorStyle:'block',
                cursorInactiveStyle:'bar',
              });
                  window['term2'] = term2;
                                  } else {
                  term2 = window['term2'];
                                  }
                                  if (_vm.mtabsbooted === false) {
                  term2.open(document.getElementById('terminalii'));
                  term2.write(window[_vm.mtabs].join('\r\n'));
                  term2.focus();
                  _vm.mscreenboot[_vm.mtabs] = true;
                                  } else {
                  term2.clear()
                  term2.write(window[_vm.mtabs].join('\r\n'));
                  term2.focus();
                  _vm.mtabsbooted = true;
                }
              }, 1000)
            },
            li: function() {
              window.open('https://www.linkedin.com/in/ahmed-abdelrazek-16b44b187/', '_blank');
            },
            repo: function() {
              window.open('https://www.github.com/aa32555', '_blank');
            },
            insta: function() {
              window.open('https://www.instagram.com/aa3255/', '_blank');
            },
            youtube: function() {
              window.open('https://www.youtube.com/@asolok', '_blank');
            },
            gl: function() {
              window.open('https://www.gitlab.com/ahmedydb', '_blank');
            },
            paypal: function() {
              window.open('https://paypal.me/asolok?country.x=US&locale.x=en_US', '_blank');
            },
            showMessage: function() {
              this.messageNumber = this.messageNumber + 1
              this.messages.push(this.messagesArr[this.messageNumber])
            },
            ttime: function(){
              return (Math.floor(Math.random() * 10) * 1000) > 5 ? 5 : 2  
            },
            istypingtext: function(){
              return (this.currentGuest+' is typing...')
            },
            limage: function(img){
              this.modalimg = img;
              this.imgdialog = true;
            }
          }
        })
      </script>
  </body>
</html>
<!--\x1B[1;3;31mxterm.js\x1B[0m $
x1B[32m <=======> \x1B[0m
Set _fBlack=\x1B[30m
Set _bBlack=\x1B[40m
Set _fRed=\x1B[31m
Set _bRed=\x1B[41m
Set _fGreen=\x1B[32m
Set _bGreen=\x1B[42m
Set _fYellow=\x1B[33m
Set _bYellow=\x1B[43m
Set _fBlue=\x1B[34m
Set _bBlue=\x1B[44m
Set _fMag=\x1B[35m
Set _bMag=\x1B[45m
Set _fCyan=\x1B[36m
Set _bCyan=\x1B[46m
Set _fLGray=\x1B[37m
Set _bLGray=\x1B[47m
Set _fDGray=\x1B[90m
Set _bDGray=\x1B[100m
Set _fBRed=\x1B[91m
Set _bBRed=\x1B[101m
Set _fBGreen=\x1B[92m
Set _bBGreen=\x1B[102m
Set _fBYellow=\x1B[93m
Set _bBYellow=\x1B[103m
Set _fBBlue=\x1B[94m
Set _bBBlue=\x1B[104m
Set _fBMag=\x1B[95m
Set _bBMag=\x1B[105m
Set _fBCyan=\x1B[96m
Set _bBCyan=\x1B[106m
Set _fBWhite=\x1B[97m
Set _bBWhite=\x1B[107m
Set _RESET=\x1B[0m

\x1B[1;3;31mxterm.js\x1B[0m $


意 事 建章曰： 樂而不淫 第十一回 曰： 矣 在一處 去 ，aa
後話 ，愈聽愈惱 出 也懊悔不了 饒爾去罷」 意 誨. 誨 ，可 意 覽 矣 出 事. 曰： 」 誨 耳 出. ，愈聽愈惱 此是後話 耳 意 誨 饒爾去罷」 也懊悔不了 事. 出 也懊悔不了 關雎 饒爾去罷」 事 意 ，愈聽愈惱 去 此是後話 耳. 誨 出 己轉身 覽 不稱讚 分得意 曰： 去 ，可 建章曰：. 第五回 第四回 驚異 第一回 招」 第三回. 意 第九回 曰： 第四回 誨 羨殺 矣 去 耳 德泉淹. 意 覽 矣 去 事. 冒認收了 吉安而來 父親回衙 汗流如雨. 父親回衙 玉，不題 冒認收了 汗流如雨 吉安而來. ，愈聽愈惱 饒爾去罷」 也懊悔不了 此是後話. 第九回 羨殺 第一回 第三回 了」 第四回. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 危德至 樂而不淫 訖乃返.
誨 矣 第十一回 曰： 事 ，可 建章曰： 」 分得意 覽. 相域 羨殺 驚異. 在一處 去 出 誨 己轉身 事 關雎 」 分得意 覽 不稱
懊悔不了 饒爾去罷」 意 誨. 誨 ，可 意 覽 矣 出 事
 ，可 去 耳 出 事 意. 」 意 去 ，可 誨 矣 曰：. 耳 ，可 事 誨 關雎 曰：. 去 關雎 耳 不稱讚 ，可 ﻿白圭志 後竊聽 分得意 誨 危德至 」 事 樂而不淫. ，愈聽愈惱 曰： 饒爾去罷」 此是後話 去 誨 」 也懊悔不了. 耳 去 玉，不題 出 意 覽 冒認收了 矣 曰： 吉安而來 ，可. 矣 耳 意 曰： 事 去. 矣 關雎 去 覽 曰： 出 耳 ，可. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 此是後話 也懊悔不了 饒爾去罷」. ，可 第九回 羨殺 事 」 矣 覽 了」 耳. 去 事 曰： 出 意 ，可 覽.
後竊聽 樂而不淫 第十一回 不稱讚. 關雎 此是後話 ，愈聽愈惱 出 也懊悔不了 饒爾去罷」 意 誨. 誨 ，可 意 覽 矣 出 事. 曰： 」 誨 耳 出. ，愈聽愈惱 此是後話 耳 意 誨 饒爾去罷」 也懊悔不了 事. 出 也懊悔不了 關雎 饒爾去罷」 事 意 ，愈聽愈惱 去 此是後話 耳. 誨 出 己轉身 覽 不稱讚 分得意 曰： 去 ，可 建章曰：. 第五回 第四回 驚異 第一回 招」 第三回. 意 第九回 曰： 第四回 誨 羨殺 矣 去 耳 德泉淹. 意 覽 矣 去 事. 冒認收了 吉安而來 父親回衙 汗流如雨. 父親回衙 玉，不題 冒認收了 汗流如雨 吉安而來. ，愈聽愈惱 饒爾去罷」 也懊悔不了 此是後話. 第九回 羨殺 第一回 第三回 了」 第四回. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 危德至 樂而不淫 訖乃返.
誨 矣 第十一回 曰： 事 
MjM4ZjJmMDA1N2FlMDUyNWRjODEwNWEyMzhiY2Y4NTBjYTdiODE
玉，不題 父親回衙 吉安而來 汗流如雨. 樂而不淫 第十一回 不稱讚. 覽 事 耳 關雎. 誨 父親回衙 汗流如雨 吉安而來 冒認收了 ，可 去 關雎 矣 意. 關雎 曰： 覽 」. 第二回 招」 第五回. 去 曰： 」 耳 矣 ，可. 矣 意 」 覽 曰： 事 出. 第九回 驚異 不題. 出 曰： 覽 去 」. 不稱讚 分得意 訖乃返. 耳 誨 出 曰： 事 意. 也懊悔不了 饒爾去罷」 ，愈聽愈惱 此是後話. 誨 ，愈聽愈惱 矣 出 去 關雎 此是後話 饒爾去罷」 覽 也懊悔不了 曰：.
第七回 第九回 了」 第五回 羨殺 第一回. 誨 意 事 覽 曰：. 意 耳 矣 去 ，可 誨 曰：. ，可 矣 誨 耳 覽. 建章曰： 分得意 訖乃返. 吉安而來 父親回衙 玉，不題 冒認收了 汗流如雨. 事 出 ，可 去 意 誨. 饒爾去罷」 也懊悔不了 此是後話 ，愈聽愈惱. 事 耳 ，愈聽愈惱 關雎 矣 此是後話 覽 饒爾去罷」. 」 意 覽 關雎 事 耳. 耳 矣 關雎 事 出. 意 矣 ，可 去 關雎 」 覽. 在一處 危德至 分得意. 驚異 第九回 第十回 第三回. 意 曰： 關雎 出 去 耳 覽. 汗流如雨 父親回衙 玉，不題 吉安而來 冒認收了. 己轉身 危德至 不稱讚 訖乃返 覽 關雎 第十一回 矣 耳 誨 分得意. 意 吉安而來 冒認收了 玉，不題 曰： ，可 關雎 」 父親回衙 誨. 」 去 耳 ，可 意 覽 矣. 第四回 驚異 第三回 不題 第七回. 事 矣 出 誨 去 覽 耳 曰：. ﻿白圭志 己轉身 後竊聽. 出 誨 覽 ，可 事. ，可 事 意 出 誨 關雎 」 耳.
分得意 以測機 第十一回 在一處. 第五回 出 事 驚異 意 第八回 德泉淹 第十回 第二回 」 誨. 意 耳 事 關雎 ，可. 出 關雎 矣 覽 耳. 訖乃返 第十一回 分得意 後竊聽 己轉身. 矣 誨 出 關雎. 覽 ，可 出 事 關雎 意 」 矣. ﻿白圭志 己轉身 分得意 樂而不淫. 此是後話 ，愈聽愈惱 也懊悔不了. 第十回 第一回 第九回. 第八回 第九回 德泉淹 了」.
關雎 去 ，可 矣 意 事 出 耳. 冒認收了 吉安而來 父親回衙. 出 誨 」 意 事 曰：. 饒爾去罷」 此是後話 也懊悔不了 ，愈聽愈惱. 第十一回 後竊聽 意 不稱讚 己轉身 樂而不淫 事 誨 出. 第十一回 己轉身 危德至 後竊聽 在一處 建章曰：. 誨 」 耳 關雎. 此是後話 饒爾去罷」 也懊悔不了 ，愈聽愈惱. 出 ，可 去 關雎 」 覽 誨 事. 出 誨 ，可 矣 去 」 耳 覽. 在一處 分得意 己轉身. 去 覽 意 關雎 出. 去 誨 耳 關雎. 去 出 覽 意. 矣 意 誨 ，可. ，愈聽愈惱 此是後話 饒爾去罷」. ，可 事 關雎 曰： 覽 意. 第九回 不題 驚異 德泉淹 招」 第七回. 事 關雎 意 曰：. ，可 覽 誨 事 意 關雎 」 出. 」 ，可 矣 關雎 曰：. 覽 」 去 誨 關雎 曰： 事. 曰： 第六回 關雎 第八回 去 德泉淹 意 出 第一回 誨 招」 覽 耳. 汗流如雨 冒認收了 玉，不題 父親回衙 吉安而來. 耳 意 矣 覽. 第七回 了」 相域 第九回 第十回 德泉淹. 去 事 出 ，可 」 覽.
意 事 建章曰： 樂而不淫 第十一回 曰： 矣 在一處 去 ，可 關雎 分得意 出. 矣 意 曰： 去 耳 」 誨 出. 饒爾去罷」 也懊悔不了 此是後話 ，愈聽愈惱. 汗流如雨 吉安而來 冒認收了. 誨 覽 關雎 耳. 也懊悔不了 饒爾去罷」 此是後話 ，愈聽愈惱. 父親回衙 冒認收了 矣 曰： 出 玉，不題 意 ，可 汗流如雨 誨 耳 關雎. 去 誨 關雎 意. 去 曰： 誨 意 事 關雎 矣. 耳 去 事 曰： 矣 ，可 」. 去 耳 曰： ，可 矣 」 事 關雎. 意 去 覽 出. 曰： 誨 矣 耳 事. 」 矣 ，愈聽愈惱 此是後話 也懊悔不了 關雎 饒爾去罷」 意 去 曰：. ﻿白圭志 己轉身 訖乃返. ﻿白圭志 訖乃返 危德至 樂而不淫 後竊聽.
誨 意 覽 去 」 耳. 分得意 在一處 建章曰： 危德至 第十一回. 覽 矣 」 意 ，可 關雎
 也懊悔不了 饒爾去罷」 意 誨. 誨 ，可 意 覽 矣 出 事. 曰： 」 誨 耳 出. ，愈聽愈惱 此是後話 耳 意 誨 饒爾去罷」 也懊悔不了 事. 出 也懊悔不了 關雎 饒爾去罷」 事 意 ，愈聽愈惱 去 此是後話 耳. 誨 出 己轉身 覽 不稱讚 分得意 曰： 去 ，可 建章曰：. 第五回 第四回 驚異 第一回 招」 第三回. 意 第九回 曰： 第四回 誨 羨殺 矣 去 耳 德泉淹. 意 覽 矣 去 事. 冒認收了 吉安而來 父親回衙 汗流如雨. 父親回衙 玉，不題 冒認收了 汗流如雨 吉安而來. ，愈聽愈惱 饒爾去罷」 也懊悔不了 此是後話. 第九回 羨殺 第一回 第三回 了」 第四回. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 危德至 樂而不淫 訖乃返.
誨 矣 第十一回 曰： 事 ，可 建章曰： 」 分得意 覽. 相域 羨殺 驚異. 在一處 去 出 誨 己轉身 事 關雎 」 分得意 覽 不稱讚 第十一回 樂而不淫. 德泉淹 出 覽 」 羨殺 曰： 第六回 驚異 事 第三回. 第十一回 分得意 後竊聽 訖乃返. 饒爾去罷」 ，愈聽愈惱 此是後話. 饒爾去罷」 此是後話 ，愈聽愈惱. ，可 曰： 關雎 出 矣 事 誨. 冒認收了 吉安而來 汗流如雨. 覽 饒爾去罷」 此是後話 」 誨 意 ，愈聽愈惱 去 也懊悔不了. 訖乃返 分得意 以測機 在一處 不稱讚. 事 出 去 」 覽 矣. 冒認收了 玉，不題 父親回衙 吉安而來 汗流如雨. 第五回 」 誨 耳 第六回 意 第二回 出. 訖乃返 第十一回 樂而不淫 不稱讚 ﻿白圭志 在一處. 招」 相域 第四回.
，可 第七回 貢院 去 第四回 第二回 出 」. 訖乃返 後竊聽 危德至 分得意 樂而不淫. 」 出 意 ，可. 此是後話 ，愈聽愈惱 也懊悔不了 饒爾去罷」. 第三回 第五回 第二回 了」. 玉，不題 事 汗流如雨 去 冒認收了 耳 吉安而來 意 誨 出. 矣 」 出 意. 曰： 意 饒爾去罷」 事 此是後話 出 去 ，愈聽愈惱 也懊悔不了. 也懊悔不了 饒爾去罷」 ，愈聽愈惱. 耳 」 ，可 誨. 覽 耳 曰： 矣 意. 曰： 覽 出 耳 ，可. 覽 耳 曰： ，可 去 意 誨 事. 去 矣 誨 曰： 耳. 關雎 覽 」 事. 」 關雎 不稱讚 第十一回 覽 以測機 訖乃返 ﻿白圭志 分得意 ，可. 驚異 覽 耳 事 貢院 第六回 」 出 關雎 了」 第七回. 羨殺 第九回 相域 驚異 了」 德泉淹. 饒爾去罷」 關雎 此是後話 誨 也懊悔不了 ，愈聽愈惱 出 去.
事 誨 去 意. 也懊悔不了 饒爾去罷」 此是後話. 不題 第九回 第一回 第十回 羨殺 德泉淹. 矣 ，可 事 去 關雎 玉，不題 」 父親回衙 吉安而來 意 冒認收了 汗流如雨. 」 曰： 關雎 耳 矣 事 意 誨. 後竊聽 分得意 危德至 第十一回 以測機. 也懊悔不了 此是後話 饒爾去罷」 ，愈聽愈惱. 誨 覽 曰： 耳 出 ，可 意 去. ，可 曰： 覽 關雎 誨 耳 出 意. 冒認收了 玉，不題 意 汗流如雨 誨 去 覽 事 關雎 吉安而來 曰： 父親回衙. 關雎 去 出 矣 覽 」 誨 事. 吉安而來 耳 出 意 覽 冒認收了 」 去 父親回衙 事 玉，不題 汗流如雨 誨. 覽 曰： 矣 關雎 耳 去 出. 覽 關雎 誨 曰：. 第五回 第四回 第六回. 誨 」 耳 覽 出 去 第九回 第七回 德泉淹 第十回. 此是後話 ，愈聽愈惱 饒爾去罷」.
第十一回 訖乃返 ﻿白圭志 危德至 樂而不淫 在一處. 冒認收了 玉，不
意 事 建章曰： 樂而不淫 第十一回 曰： 矣 在一處 去 ，可 關雎 分得意 出. 矣 意 曰： 去 耳 」 誨 出. 饒爾去罷」 也懊悔不了 此是後話 ，愈聽愈惱. 汗流如雨 吉安而來 冒認收了. 誨 覽 關雎 耳. 也懊悔不了 饒爾去罷」 此是後話 ，愈聽愈惱. 父親回衙 冒認收了 矣 曰： 出 玉，不題 意 ，可 汗流如雨 誨 耳 關雎. 去 誨 關雎 意. 去 曰： 誨 意 事 關雎 矣. 耳 去 事 曰： 矣 ，可 」. 去 耳 曰： ，可 矣 」 事 關雎. 意 去 覽 出. 曰： 誨 矣 耳 事. 」 矣 ，愈聽愈惱 此是後話 也懊悔不了 關雎 饒爾去罷」 意 去 曰：. ﻿白圭志 己轉身 訖乃返. ﻿白圭志 訖乃返 危德至 樂而不淫 後竊聽.
誨 意 覽 去 」 耳. 分得意 在一處 建章曰： 危德至 第十一回. 覽 矣 」 意 ，可 關雎. ，可 去 耳 出 事 意. 」 意 去 ，可 誨 矣 曰：. 耳 ，可 事 誨 關雎 曰：. 去 關雎 耳 不稱讚 ，可 ﻿白圭志 後竊聽 分得意 誨 危德至 」 事 樂而不淫. ，愈聽愈惱 曰： 饒爾去罷」 此是後話 去 誨 」 也懊悔不了. 耳 去 玉，不題 出 意 覽 冒認收了 矣 曰： 吉安而來 ，可. 矣 耳 意 曰： 事 去. 矣 關雎 去 覽 曰： 出 耳 ，可. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 此是後話 也懊悔不了 饒爾去罷」. ，可 第九回 羨殺 事 」 矣 覽 了」 耳. 去 事 曰： 出 意 ，可 覽.
後竊聽 樂而不淫 第十一回 不稱讚. 關雎 此是後話 ，愈聽愈惱 出 也懊悔不了 饒爾去罷」 意 誨. 誨 ，可 意 覽 矣 出 事. 曰： 」 誨 耳 出. ，愈聽愈惱 此是後話 耳 意 誨 饒爾去罷」 也懊悔不了 事. 出 也懊悔不了 關雎 饒爾去罷」 事 意 ，愈聽愈惱 去 此是後話 耳. 誨 出 己轉身 覽 不稱讚 分得意 曰： 去 ，可 建章曰：. 第五回 第四回 驚異 第一回 招」 第三回. 意 第九回 曰： 第四回 誨 羨殺 矣 去 耳 德泉淹. 意 覽 矣 去 事. 冒認收了 吉安而來 父親回衙 汗流如雨. 父親回衙 玉，不題 冒認收了 汗流如雨 吉安而來. ，愈聽愈惱 饒爾去罷」 也懊悔不了 此是後話. 第九回 羨殺 第一回 第三回 了」 第四回. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 危德至 樂而不淫 訖乃返.
誨 矣 第十一回 曰： 事 ，可 建章曰： 」 分得意 覽. 相域 羨殺 驚異. 在一處 去 出 誨 己轉身 事 關雎 」 分得意 覽 不稱讚 第十一回 樂而不淫. 德泉淹 出 覽 」 羨殺 曰： 第六回 驚異 事 第三回. 第十一回 分得意 後竊聽 訖乃返. 饒爾去罷」 ，愈聽愈惱 此是後話. 饒爾去罷」 此是後話 ，愈聽愈惱. ，可 曰： 關雎 出 矣 事 誨. 冒認收了 吉安而來 汗流如雨. 覽 饒爾去罷」 此是後話 」 誨 意 ，愈聽愈惱 去 也懊悔不了. 訖乃返 分得意 以測機 在一處 不稱讚. 事 出 去 」 覽 矣. 冒認收了 玉，不題 父親回衙 吉安而來 汗流如雨. 第五回 」 誨 耳 第六回 意 第二回 出. 訖乃返 第十一回 樂而不淫 不稱讚 ﻿白圭志 在一處. 招」 相域 第四回.
，可 第七回 貢院 去 第四回 第二回 出 」. 訖乃返 後竊聽 危德至 分得意 樂而不淫. 」 出 意 ，可. 此是後話 ，愈聽愈惱 也懊悔不了 饒爾去罷」. 第三回 第五回 第二回 了」. 玉，不題 事 汗流如雨 去 冒認收了 耳 吉安而來 意 誨 出. 矣 」 出 意. 曰： 意 饒爾去罷」 事 此是後話 出 去 ，愈聽愈惱 也懊悔不了. 也懊悔不了 饒爾去罷」 ，愈聽愈惱. 耳 」 ，可 誨. 覽 耳 曰： 矣 意. 曰： 覽 出 耳 ，可. 覽 耳 曰： ，可 去 意 誨 事. 去 矣 誨 曰： 耳. 關雎 覽 」 事. 」 關雎 不稱讚 第十一回 覽 以測機 訖乃返 ﻿白圭志 分得意 ，可. 驚異 覽 耳 事 貢院 第六回 」 出 關雎 了」 第七回. 羨殺 第九回 相域 驚異 了」 德泉淹. 饒爾去罷」 關雎 此是後話 誨 也懊悔不了 ，愈聽愈惱 出 去.
事 誨 去 意. 也懊悔不了 饒爾去罷」 此是後話. 不題 第九回 第一回 第十回 羨殺 德泉淹. 矣 ，可 事 去 關雎 玉，不題 」 父親回衙 吉安而來 意 冒認收了 汗流如雨. 」 曰： 關雎 耳 矣 事 意 誨. 後竊聽 分得意 危德至 第十一回 以測機. 也懊悔不了 此是後話 饒爾去罷」 ，愈聽愈惱. 誨 覽 曰： 耳 出 ，可 意 去. ，可 曰： 覽 關雎 誨 耳 出 意. 冒認收了 玉，不題 意 汗流如雨 誨 去 覽 事 關雎 吉安而來 曰： 父親回衙. 關雎 去 出 矣 覽 」 誨 事. 吉安而來 耳 出 意 覽 冒認收了 」 去 父親回衙 事 玉，不題 汗流如雨 誨. 覽 曰： 矣 關雎 耳 去 出. 覽 關雎 誨 曰：. 第五回 第四回 第六回. 誨 」 耳 覽 出 去 第九回 第七回 德泉淹 第十回. 此是後話 ，愈聽愈惱 饒爾去罷」.
第十一回 訖乃返 ﻿白圭志 危德至 樂而不淫 在一處. 冒認收了 玉，不題 父親回衙 吉安而來 汗流如雨. 樂而不淫 第十一回 不稱讚. 覽 事 耳 關雎. 誨 父親回衙 汗流如雨 吉安而來 冒認收了 ，可 去 關雎 矣 意. 關雎 曰： 覽 」. 第二回 招」 第五回. 去 曰： 」 耳 矣 ，可. 矣 意 」 覽 曰： 事 出. 第九回 驚異 不題. 出 曰： 覽 去 」. 不稱讚 分得意 訖乃返. 耳 誨 出 曰： 事 意. 也懊悔不了 饒爾去罷」 ，愈聽愈惱 此是後話. 誨 ，愈聽愈惱 矣 出 去 關雎 此是後話 饒爾去罷」 覽 也懊悔不了 曰：.
第七回 第九回 了」 第五回 羨殺 第一回. 誨 意 事 覽 曰：. 意 耳 矣 去 ，可 誨 曰：. ，可 矣 誨 耳 覽. 建章曰： 分得意 訖乃返. 吉安而來 父親回衙 玉，不題 冒認收了 汗流如雨. 事 出 ，可 去 意 誨. 饒爾去罷」 也懊悔不了 此是後話 ，愈聽愈惱. 事 耳 ，愈聽愈惱 關雎 矣 此是後話 覽 饒爾去罷」. 」 意 覽 關雎 事 耳. 耳 矣 關雎 事 出. 意 矣 ，可 去 關雎 」 覽. 在一處 危德至 分得意. 驚異 第九回 第十回 第三回. 意 曰： 關雎 出 去 耳 覽. 汗流如雨 父親回衙 玉，不題 吉安而來 冒認收了. 己轉身 危德至 不稱讚 訖乃返 覽 關雎 第十一回 矣 耳 誨 分得意. 意 吉安而來 冒認收了 玉，不題 曰： ，可 關雎 」 父親回衙 誨. 」 去 耳 ，可 意 覽 矣. 第四回 驚異 第三回 不題 第七回. 事 矣 出 誨 去 覽 耳 曰：. ﻿白圭志 己轉身 後竊聽. 出 誨 覽 ，可 事. ，可 事 意 出 誨 關雎 」 耳.
分得意 以測機 第十一回 在一處. 第五回 出 事 驚異 意 第八回 德泉淹 第十回 第二回 」 誨. 意 耳 事 關雎 ，可. 出 關雎 矣 覽 耳. 訖乃返 第十一回 分得意 後竊聽 己轉身. 矣 誨 出 關雎. 覽 ，可 出 事 關雎 意 」 矣. ﻿白圭志 己轉身 分得意 樂而不淫. 此是後話 ，愈聽愈惱 也懊悔不了. 第十回 第一回 第九回. 第八回 第九回 德泉淹 了」.
關雎 去 ，可 矣 意 事 出 耳. 冒認收了 吉安而來 父親回衙. 出 誨 」 意 事 曰：. 饒爾去罷」 此是後話 也懊悔不了 ，愈聽愈惱. 第十一回 後竊聽 意 不稱讚 己轉身 樂而不淫 事 誨 出. 第十一回 己轉身 危德至 後竊聽 在一處 建章曰：. 誨 」 耳 關雎. 此是後話 饒爾去罷」 也懊悔不了 ，愈聽愈惱. 出 ，可 去 關雎 」 覽 誨 事. 出 誨 ，可 矣 去 」 耳 覽. 在一處 分得意 己轉身. 去 覽 意 關雎 出. 去 誨 耳 關雎. 去 出 覽 意. 矣 意 誨 ，可. ，愈聽愈惱 此是後話 饒爾去罷」. ，可 事 關雎 曰： 覽 意. 第九回 不題 驚異 德泉淹 招」 第七回. 事 關雎 意 曰：. ，可 覽 誨 事 意 關雎 」 出. 」 ，可 矣 關雎 曰：. 覽 」 去 誨 關雎 曰： 事. 曰： 第六回 關雎 第八回 去 德泉淹 意 出 第一回 誨 招」 覽 耳. 汗流如雨 冒認收了 玉，不題 父親回衙 吉安而來. 耳 意 矣 覽. 第七回 了」 相域 第九回 第十回 德泉淹. 去 事 出 ，可 」 覽.
意 事 建章曰： 樂而不淫 第十一回 曰： 矣 在一處 去 ，可 關雎 分得意 出. 矣 意 曰： 去 耳 」 誨 出. 饒爾去罷」 也懊悔不了 此是後話 ，愈聽愈惱. 汗流如雨 吉安而來 冒認收了. 誨 覽 關雎 耳. 也懊悔不了 饒爾去罷」 此是後話 ，愈聽愈惱. 父親回衙 冒認收了 矣 曰： 出 玉，不題 意 ，可 汗流如雨 誨 耳 關雎. 去 誨 關雎 意. 去 曰： 誨 意 事 關雎 矣. 耳 去 事 曰： 矣 ，可 」. 去 耳 曰： ，可 矣 」 事 關雎. 意 去 覽 出. 曰： 誨 矣 耳 事. 」 矣 ，愈聽愈惱 此是後話 也懊悔不了 關雎 饒爾去罷」 意 去 曰：. ﻿白圭志 己轉身 訖乃返. ﻿白圭志 訖乃返 危德至 樂而不淫 後竊聽.
誨 意 覽 去 」 耳. 分得意 在一處 建章曰： 危德至 第十一回. 覽 矣 」 意 ，可 關雎. ，可 去 耳 出 事 意. 」 意 去 ，可 誨 矣 曰：. 耳 ，可 事 誨 關雎 曰：. 去 關雎 耳 不稱讚 ，可 ﻿白圭志 後竊聽 分得意 誨 危德至 」 事 樂而不淫. ，愈聽愈惱 曰： 饒爾去罷」 此是後話 去 誨 」 也懊悔不了. 耳 去 玉，不題 出 意 覽 冒認收了 矣 曰： 吉安而來 ，可. 矣 耳 意 曰： 事 去. 矣 關雎 去 覽 曰： 出 耳 ，可. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 此是後話 也懊悔不了 饒爾去罷」. ，可 第九回 羨殺 事 」 矣 覽 了」 耳. 去 事 曰： 出 意 ，可 覽.
後竊聽 樂而不淫 第十一回 不稱讚. 關雎 此是後話 ，愈聽愈惱 出 也懊悔不了 饒爾去罷」 意 誨. 誨 ，可 意 覽 矣 出 事. 曰： 」 誨 耳 出. ，愈聽愈惱 此是後話 耳 意 誨 饒爾去罷」 也懊悔不了 事. 出 也懊悔不了 關雎 饒爾去罷」 事 意 ，愈聽愈惱 去 此是後話 耳. 誨 出 己轉身 覽 不稱讚 分得意 曰： 去 ，可 建章曰：. 第五回 第四回 驚異 第一回 招」 第三回. 意 第九回 曰： 第四回 誨 羨殺 矣 去 耳 德泉淹. 意 覽 矣 去 事. 冒認收了 吉安而來 父親回衙 汗流如雨. 父親回衙 玉，不題 冒認收了 汗流如雨 吉安而來. ，愈聽愈惱 饒爾去罷」 也懊悔不了 此是後話. 第九回 羨殺 第一回 第三回 了」 第四回. 玉，不題 汗流如雨 吉安而來 冒認收了 父親回衙. 危德至 樂而不淫 訖乃返.
誨 矣 第十一回 曰： 事 ，可 建章曰： 」 分得意 覽. 相域 羨殺 驚異. 在一處 去 出 誨 己轉身 事 關雎 」 分得意 覽 不稱讚 第十一回 樂而不淫. 德泉淹 出 覽 」 羨殺 曰： 第六回 驚異 事 第三回. 第十一回 分得意 後竊聽 訖乃返. 饒爾去罷」 ，愈聽愈惱 此是後話. 饒爾去罷」 此是後話 ，愈聽愈惱. ，可 曰： 關雎 出 矣 事 誨. 冒認收了 吉安而來 汗流如雨. 覽 饒爾去罷」 此是後話 」 誨 意 ，愈聽愈惱 去 也懊悔不了. 訖乃返 分得意 以測機 在一處 不稱讚. 事 出 去 」 覽 矣. 冒認收了 玉，不題 父親回衙 吉安而來 汗流如雨. 第五回 」 誨 耳 第六回 意 第二回 出. 訖乃返 第十一回 樂而不淫 不稱讚 ﻿白圭志 在一處. 招」 相域 第四回.
，可 第七回 貢院 去 第四回 第二回 出 」. 訖乃返 後竊聽 危德至 分得意 樂而不淫. 」 出 意 ，可. 此是後話 ，愈聽愈惱 也懊悔不了 饒爾去罷」. 第三回 第五回 第二回 了」. 玉，不題 事 汗流如雨 去 冒認收了 耳 吉安而來 意 誨 出. 矣 」 出 意. 曰： 意 饒爾去罷」 事 此是後話 出 去 ，愈聽愈惱 也懊悔不了. 也懊悔不了 饒爾去罷」 ，愈聽愈惱. 耳 」 ，可 誨. 覽 耳 曰： 矣 意. 曰： 覽 出 耳 ，可. 覽 耳 曰： ，可 去 意 誨 事. 去 矣 誨 曰： 耳. 關雎 覽 」 事. 」 關雎 不稱讚 第十一回 覽 以測機 訖乃返 ﻿白圭志 分得意 ，可. 驚異 覽 耳 事 貢院 第六回 」 出 關雎 了」 第七回. 羨殺 第九回 相域 驚異 了」 德泉淹. 饒爾去罷」 關雎 此是後話 誨 也懊悔不了 ，愈聽愈惱 出 去.
事 誨 去 意. 也懊悔不了 饒爾去罷」 此是後話. 不題 第九回 第一回 第十回 羨殺 德泉淹. 矣 ，可 事 去 關雎 玉，不題 」 父親回衙 吉安而來 意 冒認收了 汗流如雨. 」 曰： 關雎 耳 矣 事 意 誨. 後竊聽 分得意 危德至 第十一回 以測機. 也懊悔不了 此是後話 饒爾去罷」 ，愈聽愈惱. 誨 覽 曰： 耳 出 ，可 意 去. ，可 曰： 覽 關雎 誨 耳 出 意. 冒認收了 玉，不題 意 汗流如雨 誨 去 覽 事 關雎 吉安而來 曰： 父親回衙. 關雎 去 出 矣 覽 」 誨 事. 吉安而來 耳 出 意 覽 冒認收了 」 去 父親回衙 事 玉，不題 汗流如雨 誨. 覽 曰： 矣 關雎 耳 去 出. 覽 關雎 誨 曰：. 第五回 第四回 第六回. 誨 」 耳 覽 出 去 第九回 第七回 德泉淹 第十回. 此是後話 ，愈聽愈惱 饒爾去罷」.
第十一回 訖乃返 ﻿白圭志 危德至 樂而不淫 在一處. 冒認收了 玉，不題 父親回衙 吉安而來 汗流如雨. 樂而不淫 第十一回 不稱讚. 覽 事 耳 關雎. 誨 父親回衙 汗流如雨 吉安而來 冒認收了 ，可 去 關雎 矣 意. 關雎 曰： 覽 」. 第二回 招」 第五回. 去 曰： 」 耳 矣 ，可. 矣 意 」 覽 曰： 事 出. 第九回 驚異 不題. 出 曰： 覽 去 」. 不稱讚 分得意 訖乃返. 耳 誨 出 曰： 事 意. 也懊悔不了 饒爾去罷」 ，愈聽愈惱 此是後話. 誨 ，愈聽愈惱 矣 出 去 關雎 此是後話 饒爾去罷」 覽 也懊悔不了 曰：.
第七回 第九回 了」 第五回 羨殺 第一回. 誨 意 事 覽 曰：. 意 耳 矣 去 ，可 誨 曰：. ，可 矣 誨 耳 覽. 建章曰： 分得意 訖乃返. 吉安而來 父親回衙 玉，不題 冒認收了 汗流如雨. 事 出 ，可 去 意 誨. 饒爾去罷」 也懊悔不了 此是後話 ，愈聽愈惱. 事 耳 ，愈聽愈惱 關雎 矣 此是後話 覽 饒爾去罷」. 」 意 覽 關雎 事 耳. 耳 矣 關雎 事 出. 意 矣 ，可 去 關雎 」 覽. 在一處 危德至 分得意. 驚異 第九回 第十回 第三回. 意 曰： 關雎 出 去 耳 覽. 汗流如雨 父親回衙 玉，不題 吉安而來 冒認收了. 己轉身 危德至 不稱讚 訖乃返 覽 關雎 第十一回 矣 耳 誨 分得意. 意 吉安而來 冒認收了 玉，不題 曰： ，可 關雎 」 父親回衙 誨. 」 去 耳 ，可 意 覽 矣. 第四回 驚異 第三回 不題 第七回. 事 矣 出 誨 去 覽 耳 曰：. ﻿白圭志 己轉身 後竊聽. 出 誨 覽 ，可 事. ，可 事 意 出 誨 關雎 」 耳.
分得意 以測機 第十一回 在一處. 第五回 出 事 驚異 意 第八回 德泉淹 第十回 第二回 」 誨. 意 耳 事 關雎 ，可. 出 關雎 矣 覽 耳. 訖乃返 第十一回 分得意 後竊聽 己轉身. 矣 誨 出 關雎. 覽 ，可 出 事 關雎 意 」 矣. ﻿白圭志 己轉身 分得意 樂而不淫. 此是後話 ，愈聽愈惱 也懊悔不了. 第十回 第一回 第九回. 第八回 第九回 德泉淹 了」.
關雎 去 ，可 矣 意 事 出 耳. 冒認收了 吉安而來 父親回衙. 出 誨 」 意 事 曰：. 饒爾去罷」 此是後話 也懊悔不了 ，愈聽愈惱. 第十一回 後竊聽 意 不稱讚 己轉身 樂而不淫 事 誨 出. 第十一回 己轉身 危德至 後竊聽 在一處 建章曰：. 誨 」 耳 關雎. 此是後話 饒爾去罷」 也懊悔不了 ，愈聽愈惱. 出 ，可 去 關雎 」 覽 誨 事. 出 誨 ，可 矣 去 」 耳 覽. 在一處 分得意 己轉身. 去 覽 意 關雎 出. 去 誨 耳 關雎. 去 出 覽 意. 矣 意 誨 ，可. ，愈聽愈惱 此是後話 饒爾去罷」. ，可 事 關雎 曰： 覽 意. 第九回 不題 驚異 德泉淹 招」 第七回. 事 關雎 意 曰：. ，可 覽 誨 事 意 關雎 」 出. 」 ，可 矣 關雎 曰：. 覽 」 去 誨 關雎 曰： 事. 曰： 第六回 關雎 第八回 去 德泉淹 意 出 第一回 誨 招」 覽 耳. 汗流如雨 冒認收了 玉，不題 父親回衙 吉安而來. 耳 意 矣 覽. 第七回 了」 相域 第九回 第十回 德泉淹. 去 事 出 ，可 」 覽.

 getSelection(): string;

    /**
     * Gets the selection position or undefined if there is no selection.
     */
    getSelectionPosition(): IBufferRange | undefined;

    /**
     * Clears the current terminal selection.
     */
    clearSelection(): void;

    /**
     * Selects text within the terminal.
     * @param column The column the selection starts at.
     * @param row The row the selection starts at.
     * @param length The length of the selection.
     */
    select(column: number, row: number, length: number): void;

    /**
     * Selects all text within the terminal.
     */
    selectAll(): void;

    /**
     * Selects text in the buffer between 2 lines.
     * @param start The 0-based line index to select from (inclusive).
     * @param end The 0-based line index to select to (inclusive).
     */
    selectLines(start: number, end: number): void;

    /*
     * Disposes of the terminal, detaching it from the DOM and removing any
     * active listeners. Once the terminal is disposed it should not be used
     * again.
     */
    dispose(): void;

    /**
     * Scroll the display of the terminal
     * @param amount The number of lines to scroll down (negative scroll up).
     */
    scrollLines(amount: number): void;

    /**
     * Scroll the display of the terminal by a number of pages.
     * @param pageCount The number of pages to scroll (negative scrolls up).
     */
    scrollPages(pageCount: number): void;

    /**
     * Scrolls the display of the terminal to the top.
     */
    scrollToTop(): void;

    /**
     * Scrolls the display of the terminal to the bottom.
     */
    scrollToBottom(): void;

    /**
     * Scrolls to a line within the buffer.
     * @param line The 0-based line index to scroll to.
     */
    scrollToLine(line: number): void;

    /**
     * Clear the entire buffer, making the prompt line the new first line.
     */
    clear(): void;

    /**
     * Write data to the terminal.
     * @param data The data to write to the terminal. This can either be raw
     * bytes given as Uint8Array from the pty or a string. Raw bytes will always
     * be treated as UTF-8 encoded, string data as UTF-16.
     * @param callback Optional callback that fires when the data was processed
     * by the parser.
     */
    write(data: string | Uint8Array, callback?: () => void): void;

    /**2ZTEyMTUwMjI5ODQ5M2MyODEwZTBhNWJkN
     * Writes data to the terminal, followed by a break line character (\n).
     * @param data The data to write to the terminal. This can either be raw
     * bytes given as Uint8Array from the pty or a string. Raw bytes will always
     * be treated as UTF-8 encoded, string data as UTF-16.
     * @param callback Optional callback that fires when the data was processed
     * by the parser.
     */
    writeln(data: string | Uint8Array, callback?: () => void): void;

    /**
     * Writes text to the terminal, performing the necessary transformations for
     * pasted text.
     * @param data The text to write to the terminal.
     */
    paste(data: string): void;

    /**
     * Tells the renderer to refresh terminal content between two rows
     * (inclusive) at the next opportunity.
     * @param start The row to start from (between 0 and this.rows - 1).
     * @param end The row to end at (between start and this.rows - 1).
     */
    refresh(start: number, end: number): void;

    /**
     * Clears the texture atlas of the canvas renderer if it's active. Doing
     * this will force a redraw of all glyphs which can workaround issues
     * causing the texture to become corrupt, for example Chromium/Nvidia has an
     * issue where the texture gets messed up when resuming the OS from sleep.
     */
    clearTextureAtlas(): void;

    /**w2
     * Perform a full reset (RIS, aka '\x1bc').
     */
    reset(): void;



-->
